/* moonshot-local-flat-file-store.c generated by valac 0.10.4, the Vala compiler
 * generated from moonshot-local-flat-file-store.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <config.h>
#include <glib/gstdio.h>


#define TYPE_IIDENTITY_CARD_STORE (iidentity_card_store_get_type ())
#define IIDENTITY_CARD_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IIDENTITY_CARD_STORE, IIdentityCardStore))
#define IS_IIDENTITY_CARD_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IIDENTITY_CARD_STORE))
#define IIDENTITY_CARD_STORE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IIDENTITY_CARD_STORE, IIdentityCardStoreIface))

typedef struct _IIdentityCardStore IIdentityCardStore;
typedef struct _IIdentityCardStoreIface IIdentityCardStoreIface;

#define TYPE_ID_CARD (id_card_get_type ())
#define ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ID_CARD, IdCard))
#define ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ID_CARD, IdCardClass))
#define IS_ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ID_CARD))
#define IS_ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ID_CARD))
#define ID_CARD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ID_CARD, IdCardClass))

typedef struct _IdCard IdCard;
typedef struct _IdCardClass IdCardClass;

#define TYPE_LOCAL_FLAT_FILE_STORE (local_flat_file_store_get_type ())
#define LOCAL_FLAT_FILE_STORE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOCAL_FLAT_FILE_STORE, LocalFlatFileStore))
#define LOCAL_FLAT_FILE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOCAL_FLAT_FILE_STORE, LocalFlatFileStoreClass))
#define IS_LOCAL_FLAT_FILE_STORE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOCAL_FLAT_FILE_STORE))
#define IS_LOCAL_FLAT_FILE_STORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOCAL_FLAT_FILE_STORE))
#define LOCAL_FLAT_FILE_STORE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOCAL_FLAT_FILE_STORE, LocalFlatFileStoreClass))

typedef struct _LocalFlatFileStore LocalFlatFileStore;
typedef struct _LocalFlatFileStoreClass LocalFlatFileStoreClass;
typedef struct _LocalFlatFileStorePrivate LocalFlatFileStorePrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))

#define TYPE_RULE (rule_get_type ())
typedef struct _Rule Rule;

#define TYPE_TRUST_ANCHOR (trust_anchor_get_type ())
#define TRUST_ANCHOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRUST_ANCHOR, TrustAnchor))
#define TRUST_ANCHOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRUST_ANCHOR, TrustAnchorClass))
#define IS_TRUST_ANCHOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRUST_ANCHOR))
#define IS_TRUST_ANCHOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRUST_ANCHOR))
#define TRUST_ANCHOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRUST_ANCHOR, TrustAnchorClass))

typedef struct _TrustAnchor TrustAnchor;
typedef struct _TrustAnchorClass TrustAnchorClass;

struct _IIdentityCardStoreIface {
	GTypeInterface parent_iface;
	void (*add_card) (IIdentityCardStore* self, IdCard* card);
	void (*remove_card) (IIdentityCardStore* self, IdCard* card);
	void (*update_card) (IIdentityCardStore* self, IdCard* card);
	GeeLinkedList* (*get_card_list) (IIdentityCardStore* self);
};

struct _LocalFlatFileStore {
	GObject parent_instance;
	LocalFlatFileStorePrivate * priv;
};

struct _LocalFlatFileStoreClass {
	GObjectClass parent_class;
};

struct _LocalFlatFileStorePrivate {
	GeeLinkedList* id_card_list;
};

struct _Rule {
	char* pattern;
	char* always_confirm;
};


static gpointer local_flat_file_store_parent_class = NULL;
static IIdentityCardStoreIface* local_flat_file_store_iidentity_card_store_parent_iface = NULL;

GType id_card_get_type (void) G_GNUC_CONST;
GType iidentity_card_store_get_type (void) G_GNUC_CONST;
GType local_flat_file_store_get_type (void) G_GNUC_CONST;
#define LOCAL_FLAT_FILE_STORE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LOCAL_FLAT_FILE_STORE, LocalFlatFileStorePrivate))
enum  {
	LOCAL_FLAT_FILE_STORE_DUMMY_PROPERTY
};
#define LOCAL_FLAT_FILE_STORE_FILE_NAME "identities.txt"
static void local_flat_file_store_real_add_card (IIdentityCardStore* base, IdCard* card);
void local_flat_file_store_store_id_cards (LocalFlatFileStore* self);
static void local_flat_file_store_real_update_card (IIdentityCardStore* base, IdCard* card);
static void local_flat_file_store_real_remove_card (IIdentityCardStore* base, IdCard* card);
static GeeLinkedList* local_flat_file_store_real_get_card_list (IIdentityCardStore* base);
static void local_flat_file_store_load_id_cards (LocalFlatFileStore* self);
static char* local_flat_file_store_get_data_dir (LocalFlatFileStore* self);
IdCard* id_card_new (void);
IdCard* id_card_construct (GType object_type);
void id_card_set_issuer (IdCard* self, const char* value);
void id_card_set_username (IdCard* self, const char* value);
void id_card_set_password (IdCard* self, const char* value);
void id_card_set_services (IdCard* self, char** value, int value_length1);
void id_card_set_display_name (IdCard* self, const char* value);
GdkPixbuf* find_icon (const char* name, gint size);
GType rule_get_type (void) G_GNUC_CONST;
Rule* rule_dup (const Rule* self);
void rule_free (Rule* self);
void rule_copy (const Rule* self, Rule* dest);
void rule_destroy (Rule* self);
void id_card_set_rules (IdCard* self, Rule* value, int value_length1);
static void _vala_Rule_array_free (Rule* array, gint array_length);
GType trust_anchor_get_type (void) G_GNUC_CONST;
TrustAnchor* id_card_get_trust_anchor (IdCard* self);
void trust_anchor_set_ca_cert (TrustAnchor* self, const char* value);
void trust_anchor_set_subject (TrustAnchor* self, const char* value);
void trust_anchor_set_subject_alt (TrustAnchor* self, const char* value);
void trust_anchor_set_server_cert (TrustAnchor* self, const char* value);
Rule* id_card_get_rules (IdCard* self, int* result_length1);
const char* id_card_get_issuer (IdCard* self);
const char* id_card_get_display_name (IdCard* self);
const char* id_card_get_username (IdCard* self);
const char* id_card_get_password (IdCard* self);
char** id_card_get_services (IdCard* self, int* result_length1);
static char** _vala_array_dup1 (char** self, int length);
const char* trust_anchor_get_ca_cert (TrustAnchor* self);
const char* trust_anchor_get_subject (TrustAnchor* self);
const char* trust_anchor_get_subject_alt (TrustAnchor* self);
const char* trust_anchor_get_server_cert (TrustAnchor* self);
LocalFlatFileStore* local_flat_file_store_new (void);
LocalFlatFileStore* local_flat_file_store_construct (GType object_type);
static void local_flat_file_store_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);



static void local_flat_file_store_real_add_card (IIdentityCardStore* base, IdCard* card) {
	LocalFlatFileStore * self;
	self = (LocalFlatFileStore*) base;
	g_return_if_fail (card != NULL);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->id_card_list, card);
	local_flat_file_store_store_id_cards (self);
}


static void local_flat_file_store_real_update_card (IIdentityCardStore* base, IdCard* card) {
	LocalFlatFileStore * self;
	self = (LocalFlatFileStore*) base;
	g_return_if_fail (card != NULL);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->id_card_list, card);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->id_card_list, card);
	local_flat_file_store_store_id_cards (self);
}


static void local_flat_file_store_real_remove_card (IIdentityCardStore* base, IdCard* card) {
	LocalFlatFileStore * self;
	self = (LocalFlatFileStore*) base;
	g_return_if_fail (card != NULL);
	gee_abstract_collection_remove ((GeeAbstractCollection*) self->priv->id_card_list, card);
	local_flat_file_store_store_id_cards (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GeeLinkedList* local_flat_file_store_real_get_card_list (IIdentityCardStore* base) {
	LocalFlatFileStore * self;
	GeeLinkedList* result = NULL;
	self = (LocalFlatFileStore*) base;
	result = _g_object_ref0 (self->priv->id_card_list);
	return result;
}


static void _vala_Rule_array_free (Rule* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			rule_destroy (&array[i]);
		}
	}
	g_free (array);
}


static void local_flat_file_store_load_id_cards (LocalFlatFileStore* self) {
	GKeyFile* key_file;
	char* path;
	char* filename;
	gint identities_uris_length1;
	gint _identities_uris_size_;
	char** _tmp1_;
	gsize _tmp0_;
	char** identities_uris;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	gee_abstract_collection_clear ((GeeAbstractCollection*) self->priv->id_card_list);
	key_file = g_key_file_new ();
	path = local_flat_file_store_get_data_dir (self);
	filename = g_build_filename (path, LOCAL_FLAT_FILE_STORE_FILE_NAME, NULL);
	{
		g_key_file_load_from_file (key_file, filename, G_KEY_FILE_NONE, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stdout, "Error: %s\n", e->message);
			_g_error_free0 (e);
			_g_free0 (filename);
			_g_free0 (path);
			_g_key_file_free0 (key_file);
			return;
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_free0 (filename);
		_g_free0 (path);
		_g_key_file_free0 (key_file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	identities_uris = (_tmp1_ = g_key_file_get_groups (key_file, &_tmp0_), identities_uris_length1 = _tmp0_, _identities_uris_size_ = identities_uris_length1, _tmp1_);
	{
		char** identity_collection;
		int identity_collection_length1;
		int identity_it;
		identity_collection = identities_uris;
		identity_collection_length1 = identities_uris_length1;
		for (identity_it = 0; identity_it < identities_uris_length1; identity_it = identity_it + 1) {
			char* identity;
			identity = g_strdup (identity_collection[identity_it]);
			{
				{
					IdCard* id_card;
					char* _tmp2_;
					char* _tmp3_;
					char* _tmp4_;
					char* _tmp5_;
					char* _tmp6_;
					char* _tmp7_;
					gint _tmp9__length1;
					gint __tmp9__size_;
					char** _tmp10_;
					gsize _tmp8_;
					char** _tmp9_;
					char** _tmp11_;
					gint _tmp11__length1;
					char** _tmp12_;
					char* _tmp13_;
					char* _tmp14_;
					gboolean _tmp15_ = FALSE;
					gboolean _tmp16_;
					char* _tmp27_;
					char* _tmp28_;
					char* _tmp29_;
					char* _tmp30_;
					char* _tmp31_;
					char* _tmp32_;
					char* _tmp33_;
					char* _tmp34_;
					id_card = id_card_new ();
					_tmp2_ = g_key_file_get_string (key_file, identity, "Issuer", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					id_card_set_issuer (id_card, _tmp3_ = _tmp2_);
					_g_free0 (_tmp3_);
					_tmp4_ = g_key_file_get_string (key_file, identity, "Username", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					id_card_set_username (id_card, _tmp5_ = _tmp4_);
					_g_free0 (_tmp5_);
					_tmp6_ = g_key_file_get_string (key_file, identity, "Password", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					id_card_set_password (id_card, _tmp7_ = _tmp6_);
					_g_free0 (_tmp7_);
					_tmp9_ = (_tmp10_ = g_key_file_get_string_list (key_file, identity, "Services", &_tmp8_, &_inner_error_), _tmp9__length1 = _tmp8_, __tmp9__size_ = _tmp9__length1, _tmp10_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					_tmp12_ = (_tmp11_ = _tmp9_, _tmp11__length1 = _tmp9__length1, _tmp11_);
					id_card_set_services (id_card, _tmp12_, _tmp9__length1);
					_tmp11_ = (_vala_array_free (_tmp11_, _tmp11__length1, (GDestroyNotify) g_free), NULL);
					_tmp13_ = g_key_file_get_string (key_file, identity, "DisplayName", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					id_card_set_display_name (id_card, _tmp14_ = _tmp13_);
					_g_free0 (_tmp14_);
					g_object_set_data_full ((GObject*) id_card, "pixbuf", find_icon ("avatar-default", 48), g_object_unref);
					_tmp16_ = g_key_file_has_key (key_file, identity, "Rules-Patterns", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					if (_tmp16_) {
						gboolean _tmp17_;
						_tmp17_ = g_key_file_has_key (key_file, identity, "Rules-AlwaysConfirm", &_inner_error_);
						if (_inner_error_ != NULL) {
							_g_object_unref0 (id_card);
							goto __catch3_g_error;
						}
						_tmp15_ = _tmp17_;
					} else {
						_tmp15_ = FALSE;
					}
					if (_tmp15_) {
						gint rules_patterns_length1;
						gint _rules_patterns_size_;
						char** _tmp19_;
						gsize _tmp18_;
						char** rules_patterns;
						gint rules_always_conf_length1;
						gint _rules_always_conf_size_;
						char** _tmp21_;
						gsize _tmp20_;
						char** rules_always_conf;
						rules_patterns = (_tmp19_ = g_key_file_get_string_list (key_file, identity, "Rules-Patterns", &_tmp18_, &_inner_error_), rules_patterns_length1 = _tmp18_, _rules_patterns_size_ = rules_patterns_length1, _tmp19_);
						if (_inner_error_ != NULL) {
							_g_object_unref0 (id_card);
							goto __catch3_g_error;
						}
						rules_always_conf = (_tmp21_ = g_key_file_get_string_list (key_file, identity, "Rules-AlwaysConfirm", &_tmp20_, &_inner_error_), rules_always_conf_length1 = _tmp20_, _rules_always_conf_size_ = rules_always_conf_length1, _tmp21_);
						if (_inner_error_ != NULL) {
							rules_patterns = (_vala_array_free (rules_patterns, rules_patterns_length1, (GDestroyNotify) g_free), NULL);
							_g_object_unref0 (id_card);
							goto __catch3_g_error;
						}
						if (rules_patterns_length1 == rules_always_conf_length1) {
							gint rules_length1;
							gint _rules_size_;
							Rule* _tmp22_;
							Rule* rules;
							Rule* _tmp26_;
							rules = (_tmp22_ = g_new0 (Rule, rules_patterns_length1), rules_length1 = rules_patterns_length1, _rules_size_ = rules_length1, _tmp22_);
							{
								gint i;
								i = 0;
								{
									gboolean _tmp23_;
									_tmp23_ = TRUE;
									while (TRUE) {
										Rule _tmp24_ = {0};
										Rule _tmp25_;
										if (!_tmp23_) {
											i++;
										}
										_tmp23_ = FALSE;
										if (!(i < rules_patterns_length1)) {
											break;
										}
										rules[i] = (_tmp25_ = (_tmp24_.pattern = g_strdup (rules_patterns[i]), _tmp24_.always_confirm = g_strdup (rules_always_conf[i]), _tmp24_), rule_destroy (&rules[i]), _tmp25_);
									}
								}
							}
							_tmp26_ = rules;
							id_card_set_rules (id_card, _tmp26_, rules_length1);
							rules = (_vala_Rule_array_free (rules, rules_length1), NULL);
						}
						rules_always_conf = (_vala_array_free (rules_always_conf, rules_always_conf_length1, (GDestroyNotify) g_free), NULL);
						rules_patterns = (_vala_array_free (rules_patterns, rules_patterns_length1, (GDestroyNotify) g_free), NULL);
					}
					_tmp27_ = g_key_file_get_string (key_file, identity, "CA-Cert", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					trust_anchor_set_ca_cert (id_card_get_trust_anchor (id_card), _tmp28_ = _tmp27_);
					_g_free0 (_tmp28_);
					_tmp29_ = g_key_file_get_string (key_file, identity, "Subject", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					trust_anchor_set_subject (id_card_get_trust_anchor (id_card), _tmp30_ = _tmp29_);
					_g_free0 (_tmp30_);
					_tmp31_ = g_key_file_get_string (key_file, identity, "SubjectAlt", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					trust_anchor_set_subject_alt (id_card_get_trust_anchor (id_card), _tmp32_ = _tmp31_);
					_g_free0 (_tmp32_);
					_tmp33_ = g_key_file_get_string (key_file, identity, "ServerCert", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch3_g_error;
					}
					trust_anchor_set_server_cert (id_card_get_trust_anchor (id_card), _tmp34_ = _tmp33_);
					_g_free0 (_tmp34_);
					gee_abstract_collection_add ((GeeAbstractCollection*) self->priv->id_card_list, id_card);
					_g_object_unref0 (id_card);
				}
				goto __finally3;
				__catch3_g_error:
				{
					GError * e;
					e = _inner_error_;
					_inner_error_ = NULL;
					{
						fprintf (stdout, "Error:  %s\n", e->message);
						_g_error_free0 (e);
					}
				}
				__finally3:
				if (_inner_error_ != NULL) {
					_g_free0 (identity);
					identities_uris = (_vala_array_free (identities_uris, identities_uris_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (filename);
					_g_free0 (path);
					_g_key_file_free0 (key_file);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				_g_free0 (identity);
			}
		}
	}
	identities_uris = (_vala_array_free (identities_uris, identities_uris_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (filename);
	_g_free0 (path);
	_g_key_file_free0 (key_file);
}


static char* local_flat_file_store_get_data_dir (LocalFlatFileStore* self) {
	char* result = NULL;
	char* path;
	char* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	path = NULL;
	path = (_tmp0_ = g_build_filename (g_get_user_data_dir (), PACKAGE_TARNAME, NULL), _g_free0 (path), _tmp0_);
	if (!g_file_test (path, G_FILE_TEST_EXISTS)) {
		g_mkdir_with_parents (path, 0700);
	}
	result = path;
	return result;
}


static char** _vala_array_dup1 (char** self, int length) {
	char** result;
	int i;
	result = g_new0 (char*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


void local_flat_file_store_store_id_cards (LocalFlatFileStore* self) {
	GKeyFile* key_file;
	char* text;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	key_file = g_key_file_new ();
	{
		GeeIterator* _id_card_it;
		_id_card_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->priv->id_card_list);
		while (TRUE) {
			IdCard* id_card;
			gint rules_patterns_length1;
			gint _rules_patterns_size_;
			char** _tmp1_;
			gint _tmp0_;
			char** rules_patterns;
			gint rules_always_conf_length1;
			gint _rules_always_conf_size_;
			char** _tmp3_;
			gint _tmp2_;
			char** rules_always_conf;
			char* _tmp10_;
			char* _tmp12_;
			char* _tmp14_;
			char* _tmp16_;
			gint _tmp20__length1;
			gint __tmp20__size_;
			char** _tmp21_;
			gint _tmp18_;
			char** _tmp19_;
			char** _tmp20_;
			gint _tmp24_;
			char* _tmp25_;
			char* _tmp27_;
			char* _tmp29_;
			char* _tmp31_;
			if (!gee_iterator_next (_id_card_it)) {
				break;
			}
			id_card = (IdCard*) gee_iterator_get (_id_card_it);
			rules_patterns = (_tmp1_ = g_new0 (char*, _tmp0_ + 1), rules_patterns_length1 = _tmp0_, _rules_patterns_size_ = rules_patterns_length1, _tmp1_);
			rules_always_conf = (_tmp3_ = g_new0 (char*, _tmp2_ + 1), rules_always_conf_length1 = _tmp2_, _rules_always_conf_size_ = rules_always_conf_length1, _tmp3_);
			{
				gint i;
				i = 0;
				{
					gboolean _tmp4_;
					_tmp4_ = TRUE;
					while (TRUE) {
						gint _tmp5_;
						gint _tmp6_;
						char* _tmp7_;
						gint _tmp8_;
						char* _tmp9_;
						if (!_tmp4_) {
							i++;
						}
						_tmp4_ = FALSE;
						if (!(i < _tmp5_)) {
							break;
						}
						rules_patterns[i] = (_tmp7_ = g_strdup (id_card_get_rules (id_card, &_tmp6_)[i].pattern), _g_free0 (rules_patterns[i]), _tmp7_);
						rules_always_conf[i] = (_tmp9_ = g_strdup (id_card_get_rules (id_card, &_tmp8_)[i].always_confirm), _g_free0 (rules_always_conf[i]), _tmp9_);
					}
				}
			}
			_tmp10_ = g_strdup (id_card_get_issuer (id_card));
			if (_tmp10_ == NULL) {
				char* _tmp11_;
				_tmp10_ = (_tmp11_ = g_strdup (""), _g_free0 (_tmp10_), _tmp11_);
			}
			g_key_file_set_string (key_file, id_card_get_display_name (id_card), "Issuer", _tmp10_);
			_tmp12_ = g_strdup (id_card_get_display_name (id_card));
			if (_tmp12_ == NULL) {
				char* _tmp13_;
				_tmp12_ = (_tmp13_ = g_strdup (""), _g_free0 (_tmp12_), _tmp13_);
			}
			g_key_file_set_string (key_file, id_card_get_display_name (id_card), "DisplayName", _tmp12_);
			_tmp14_ = g_strdup (id_card_get_username (id_card));
			if (_tmp14_ == NULL) {
				char* _tmp15_;
				_tmp14_ = (_tmp15_ = g_strdup (""), _g_free0 (_tmp14_), _tmp15_);
			}
			g_key_file_set_string (key_file, id_card_get_display_name (id_card), "Username", _tmp14_);
			_tmp16_ = g_strdup (id_card_get_password (id_card));
			if (_tmp16_ == NULL) {
				char* _tmp17_;
				_tmp16_ = (_tmp17_ = g_strdup (""), _g_free0 (_tmp16_), _tmp17_);
			}
			g_key_file_set_string (key_file, id_card_get_display_name (id_card), "Password", _tmp16_);
			_tmp20_ = (_tmp21_ = (_tmp19_ = id_card_get_services (id_card, &_tmp18_), (_tmp19_ == NULL) ? ((gpointer) _tmp19_) : _vala_array_dup1 (_tmp19_, _tmp18_)), _tmp20__length1 = _tmp18_, __tmp20__size_ = _tmp20__length1, _tmp21_);
			if (_tmp20_ == NULL) {
				char** _tmp22_ = NULL;
				char** _tmp23_;
				_tmp20_ = (_tmp23_ = (_tmp22_ = g_new0 (char*, 0 + 1), _tmp22_), _tmp20_ = (_vala_array_free (_tmp20_, _tmp20__length1, (GDestroyNotify) g_free), NULL), _tmp20__length1 = 0, __tmp20__size_ = _tmp20__length1, _tmp23_);
			}
			g_key_file_set_string_list (key_file, id_card_get_display_name (id_card), "Services", (const gchar* const*) _tmp20_, _tmp20__length1);
			if (_tmp24_ > 0) {
				g_key_file_set_string_list (key_file, id_card_get_display_name (id_card), "Rules-Patterns", (const gchar* const*) rules_patterns, rules_patterns_length1);
				g_key_file_set_string_list (key_file, id_card_get_display_name (id_card), "Rules-AlwaysConfirm", (const gchar* const*) rules_always_conf, rules_always_conf_length1);
			}
			_tmp25_ = g_strdup (trust_anchor_get_ca_cert (id_card_get_trust_anchor (id_card)));
			if (_tmp25_ == NULL) {
				char* _tmp26_;
				_tmp25_ = (_tmp26_ = g_strdup (""), _g_free0 (_tmp25_), _tmp26_);
			}
			g_key_file_set_string (key_file, id_card_get_display_name (id_card), "CA-Cert", _tmp25_);
			_tmp27_ = g_strdup (trust_anchor_get_subject (id_card_get_trust_anchor (id_card)));
			if (_tmp27_ == NULL) {
				char* _tmp28_;
				_tmp27_ = (_tmp28_ = g_strdup (""), _g_free0 (_tmp27_), _tmp28_);
			}
			g_key_file_set_string (key_file, id_card_get_display_name (id_card), "Subject", _tmp27_);
			_tmp29_ = g_strdup (trust_anchor_get_subject_alt (id_card_get_trust_anchor (id_card)));
			if (_tmp29_ == NULL) {
				char* _tmp30_;
				_tmp29_ = (_tmp30_ = g_strdup (""), _g_free0 (_tmp29_), _tmp30_);
			}
			g_key_file_set_string (key_file, id_card_get_display_name (id_card), "SubjectAlt", _tmp29_);
			_tmp31_ = g_strdup (trust_anchor_get_server_cert (id_card_get_trust_anchor (id_card)));
			if (_tmp31_ == NULL) {
				char* _tmp32_;
				_tmp31_ = (_tmp32_ = g_strdup (""), _g_free0 (_tmp31_), _tmp32_);
			}
			g_key_file_set_string (key_file, id_card_get_display_name (id_card), "ServerCert", _tmp31_);
			_g_free0 (_tmp31_);
			_g_free0 (_tmp29_);
			_g_free0 (_tmp27_);
			_g_free0 (_tmp25_);
			_tmp20_ = (_vala_array_free (_tmp20_, _tmp20__length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (_tmp16_);
			_g_free0 (_tmp14_);
			_g_free0 (_tmp12_);
			_g_free0 (_tmp10_);
			rules_always_conf = (_vala_array_free (rules_always_conf, rules_always_conf_length1, (GDestroyNotify) g_free), NULL);
			rules_patterns = (_vala_array_free (rules_patterns, rules_patterns_length1, (GDestroyNotify) g_free), NULL);
			_g_object_unref0 (id_card);
		}
		_g_object_unref0 (_id_card_it);
	}
	text = g_key_file_to_data (key_file, NULL, NULL);
	{
		char* path;
		char* filename;
		path = local_flat_file_store_get_data_dir (self);
		filename = g_build_filename (path, LOCAL_FLAT_FILE_STORE_FILE_NAME, NULL);
		g_file_set_contents (filename, text, (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (filename);
			_g_free0 (path);
			goto __catch4_g_error;
		}
		_g_free0 (filename);
		_g_free0 (path);
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stdout, "Error:  %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_free0 (text);
		_g_key_file_free0 (key_file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	local_flat_file_store_load_id_cards (self);
	_g_free0 (text);
	_g_key_file_free0 (key_file);
}


LocalFlatFileStore* local_flat_file_store_construct (GType object_type) {
	LocalFlatFileStore * self = NULL;
	GeeLinkedList* _tmp0_;
	self = (LocalFlatFileStore*) g_object_new (object_type, NULL);
	self->priv->id_card_list = (_tmp0_ = gee_linked_list_new (TYPE_ID_CARD, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (self->priv->id_card_list), _tmp0_);
	local_flat_file_store_load_id_cards (self);
	return self;
}


LocalFlatFileStore* local_flat_file_store_new (void) {
	return local_flat_file_store_construct (TYPE_LOCAL_FLAT_FILE_STORE);
}


static void local_flat_file_store_class_init (LocalFlatFileStoreClass * klass) {
	local_flat_file_store_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (LocalFlatFileStorePrivate));
	G_OBJECT_CLASS (klass)->finalize = local_flat_file_store_finalize;
}


static void local_flat_file_store_iidentity_card_store_interface_init (IIdentityCardStoreIface * iface) {
	local_flat_file_store_iidentity_card_store_parent_iface = g_type_interface_peek_parent (iface);
	iface->add_card = local_flat_file_store_real_add_card;
	iface->update_card = local_flat_file_store_real_update_card;
	iface->remove_card = local_flat_file_store_real_remove_card;
	iface->get_card_list = local_flat_file_store_real_get_card_list;
}


static void local_flat_file_store_instance_init (LocalFlatFileStore * self) {
	self->priv = LOCAL_FLAT_FILE_STORE_GET_PRIVATE (self);
}


static void local_flat_file_store_finalize (GObject* obj) {
	LocalFlatFileStore * self;
	self = LOCAL_FLAT_FILE_STORE (obj);
	_g_object_unref0 (self->priv->id_card_list);
	G_OBJECT_CLASS (local_flat_file_store_parent_class)->finalize (obj);
}


GType local_flat_file_store_get_type (void) {
	static volatile gsize local_flat_file_store_type_id__volatile = 0;
	if (g_once_init_enter (&local_flat_file_store_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LocalFlatFileStoreClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) local_flat_file_store_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LocalFlatFileStore), 0, (GInstanceInitFunc) local_flat_file_store_instance_init, NULL };
		static const GInterfaceInfo iidentity_card_store_info = { (GInterfaceInitFunc) local_flat_file_store_iidentity_card_store_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType local_flat_file_store_type_id;
		local_flat_file_store_type_id = g_type_register_static (G_TYPE_OBJECT, "LocalFlatFileStore", &g_define_type_info, 0);
		g_type_add_interface_static (local_flat_file_store_type_id, TYPE_IIDENTITY_CARD_STORE, &iidentity_card_store_info);
		g_once_init_leave (&local_flat_file_store_type_id__volatile, local_flat_file_store_type_id);
	}
	return local_flat_file_store_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}




