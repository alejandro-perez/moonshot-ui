/* moonshot-identities-manager.c generated by valac 0.10.4, the Vala compiler
 * generated from moonshot-identities-manager.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <glib/gstdio.h>
#include <config.h>
#include <gdk-pixbuf/gdk-pixdata.h>


#define TYPE_IDENTITIES_MANAGER (identities_manager_get_type ())
#define IDENTITIES_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDENTITIES_MANAGER, IdentitiesManager))
#define IDENTITIES_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDENTITIES_MANAGER, IdentitiesManagerClass))
#define IS_IDENTITIES_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDENTITIES_MANAGER))
#define IS_IDENTITIES_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDENTITIES_MANAGER))
#define IDENTITIES_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDENTITIES_MANAGER, IdentitiesManagerClass))

typedef struct _IdentitiesManager IdentitiesManager;
typedef struct _IdentitiesManagerClass IdentitiesManagerClass;
typedef struct _IdentitiesManagerPrivate IdentitiesManagerPrivate;

#define TYPE_ID_CARD (id_card_get_type ())
#define ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ID_CARD, IdCard))
#define ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ID_CARD, IdCardClass))
#define IS_ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ID_CARD))
#define IS_ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ID_CARD))
#define ID_CARD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ID_CARD, IdCardClass))

typedef struct _IdCard IdCard;
typedef struct _IdCardClass IdCardClass;
#define __g_slist_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_slist_free_g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _IdentitiesManager {
	GObject parent_instance;
	IdentitiesManagerPrivate * priv;
	GSList* id_card_list;
};

struct _IdentitiesManagerClass {
	GObjectClass parent_class;
};


static gpointer identities_manager_parent_class = NULL;

GType identities_manager_get_type (void) G_GNUC_CONST;
GType id_card_get_type (void) G_GNUC_CONST;
enum  {
	IDENTITIES_MANAGER_DUMMY_PROPERTY
};
static void _g_slist_free_g_object_unref (GSList* self);
#define IDENTITIES_MANAGER_FILE_NAME "identities.txt"
IdentitiesManager* identities_manager_new (void);
IdentitiesManager* identities_manager_construct (GType object_type);
static char* identities_manager_get_data_dir (IdentitiesManager* self);
IdCard* id_card_new (void);
IdCard* id_card_construct (GType object_type);
void id_card_set_issuer (IdCard* self, const char* value);
void id_card_set_username (IdCard* self, const char* value);
void id_card_set_password (IdCard* self, const char* value);
void id_card_set_services (IdCard* self, char** value, int value_length1);
const char* id_card_get_username (IdCard* self);
const char* id_card_get_issuer (IdCard* self);
void id_card_set_nai (IdCard* self, const char* value);
void identities_manager_store_id_cards (IdentitiesManager* self);
const char* id_card_get_password (IdCard* self);
char** id_card_get_services (IdCard* self, int* result_length1);
IdCard* identities_manager_load_gss_eap_id_file (IdentitiesManager* self);
GdkPixbuf* find_icon (const char* name, gint size);
void id_card_set_pixbuf (IdCard* self, GdkPixbuf* value);
void identities_manager_store_gss_eap_id_file (IdentitiesManager* self, IdCard* id_card);
static void identities_manager_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);



static void _g_slist_free_g_object_unref (GSList* self) {
	g_slist_foreach (self, (GFunc) g_object_unref, NULL);
	g_slist_free (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


IdentitiesManager* identities_manager_construct (GType object_type) {
	IdentitiesManager * self = NULL;
	GKeyFile* key_file;
	char* path;
	char* filename;
	gint identities_uris_length1;
	gint _identities_uris_size_;
	char** _tmp1_;
	gsize _tmp0_;
	char** identities_uris;
	GError * _inner_error_ = NULL;
	self = (IdentitiesManager*) g_object_new (object_type, NULL);
	key_file = g_key_file_new ();
	path = identities_manager_get_data_dir (self);
	filename = g_build_filename (path, IDENTITIES_MANAGER_FILE_NAME, NULL);
	{
		g_key_file_load_from_file (key_file, filename, G_KEY_FILE_NONE, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stdout, "Error: %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_free0 (filename);
		_g_free0 (path);
		_g_key_file_free0 (key_file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	identities_uris = (_tmp1_ = g_key_file_get_groups (key_file, &_tmp0_), identities_uris_length1 = _tmp0_, _identities_uris_size_ = identities_uris_length1, _tmp1_);
	{
		char** identity_collection;
		int identity_collection_length1;
		int identity_it;
		identity_collection = identities_uris;
		identity_collection_length1 = identities_uris_length1;
		for (identity_it = 0; identity_it < identities_uris_length1; identity_it = identity_it + 1) {
			char* identity;
			identity = g_strdup (identity_collection[identity_it]);
			{
				{
					IdCard* id_card;
					char* _tmp2_;
					char* _tmp3_;
					char* _tmp4_;
					char* _tmp5_;
					char* _tmp6_;
					char* _tmp7_;
					gint _tmp9__length1;
					gint __tmp9__size_;
					char** _tmp10_;
					gsize _tmp8_;
					char** _tmp9_;
					char** _tmp11_;
					gint _tmp11__length1;
					char** _tmp12_;
					char* _tmp13_;
					char* _tmp14_;
					id_card = id_card_new ();
					_tmp2_ = g_key_file_get_string (key_file, identity, "Issuer", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch1_g_error;
					}
					id_card_set_issuer (id_card, _tmp3_ = _tmp2_);
					_g_free0 (_tmp3_);
					_tmp4_ = g_key_file_get_string (key_file, identity, "Username", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch1_g_error;
					}
					id_card_set_username (id_card, _tmp5_ = _tmp4_);
					_g_free0 (_tmp5_);
					_tmp6_ = g_key_file_get_string (key_file, identity, "Password", &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch1_g_error;
					}
					id_card_set_password (id_card, _tmp7_ = _tmp6_);
					_g_free0 (_tmp7_);
					_tmp9_ = (_tmp10_ = g_key_file_get_string_list (key_file, identity, "Services", &_tmp8_, &_inner_error_), _tmp9__length1 = _tmp8_, __tmp9__size_ = _tmp9__length1, _tmp10_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (id_card);
						goto __catch1_g_error;
					}
					_tmp12_ = (_tmp11_ = _tmp9_, _tmp11__length1 = _tmp9__length1, _tmp11_);
					id_card_set_services (id_card, _tmp12_, _tmp9__length1);
					_tmp11_ = (_vala_array_free (_tmp11_, _tmp11__length1, (GDestroyNotify) g_free), NULL);
					id_card_set_nai (id_card, _tmp14_ = g_strconcat (_tmp13_ = g_strconcat (id_card_get_username (id_card), "@", NULL), id_card_get_issuer (id_card), NULL));
					_g_free0 (_tmp14_);
					_g_free0 (_tmp13_);
					self->id_card_list = g_slist_prepend (self->id_card_list, _g_object_ref0 (id_card));
					_g_object_unref0 (id_card);
				}
				goto __finally1;
				__catch1_g_error:
				{
					GError * e;
					e = _inner_error_;
					_inner_error_ = NULL;
					{
						fprintf (stdout, "Error:  %s\n", e->message);
						_g_error_free0 (e);
					}
				}
				__finally1:
				if (_inner_error_ != NULL) {
					_g_free0 (identity);
					identities_uris = (_vala_array_free (identities_uris, identities_uris_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (filename);
					_g_free0 (path);
					_g_key_file_free0 (key_file);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				_g_free0 (identity);
			}
		}
	}
	identities_uris = (_vala_array_free (identities_uris, identities_uris_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (filename);
	_g_free0 (path);
	_g_key_file_free0 (key_file);
	return self;
}


IdentitiesManager* identities_manager_new (void) {
	return identities_manager_construct (TYPE_IDENTITIES_MANAGER);
}


void identities_manager_store_id_cards (IdentitiesManager* self) {
	GKeyFile* key_file;
	char* text;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	key_file = g_key_file_new ();
	{
		GSList* id_card_collection;
		GSList* id_card_it;
		id_card_collection = self->id_card_list;
		for (id_card_it = id_card_collection; id_card_it != NULL; id_card_it = id_card_it->next) {
			IdCard* id_card;
			id_card = _g_object_ref0 ((IdCard*) id_card_it->data);
			{
				gint _tmp0_;
				g_key_file_set_string (key_file, id_card_get_issuer (id_card), "Issuer", id_card_get_issuer (id_card));
				g_key_file_set_string (key_file, id_card_get_issuer (id_card), "Username", id_card_get_username (id_card));
				g_key_file_set_string (key_file, id_card_get_issuer (id_card), "Password", id_card_get_password (id_card));
				g_key_file_set_string_list (key_file, id_card_get_issuer (id_card), "Services", (const gchar* const*) id_card_get_services (id_card, &_tmp0_), _tmp0_);
				_g_object_unref0 (id_card);
			}
		}
	}
	text = g_key_file_to_data (key_file, NULL, NULL);
	{
		char* path;
		char* filename;
		path = identities_manager_get_data_dir (self);
		filename = g_build_filename (path, IDENTITIES_MANAGER_FILE_NAME, NULL);
		g_file_set_contents (filename, text, (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (filename);
			_g_free0 (path);
			goto __catch2_g_error;
		}
		_g_free0 (filename);
		_g_free0 (path);
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stdout, "Error:  %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_free0 (text);
		_g_key_file_free0 (key_file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (text);
	_g_key_file_free0 (key_file);
}


static char* identities_manager_get_data_dir (IdentitiesManager* self) {
	char* result = NULL;
	char* path;
	char* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	path = NULL;
	path = (_tmp0_ = g_build_filename (g_get_user_data_dir (), PACKAGE_TARNAME, NULL), _g_free0 (path), _tmp0_);
	if (!g_file_test (path, G_FILE_TEST_EXISTS)) {
		g_mkdir (path, 0700);
	}
	result = path;
	return result;
}


IdCard* identities_manager_load_gss_eap_id_file (IdentitiesManager* self) {
	IdCard* result = NULL;
	IdCard* id_card;
	char* text;
	char* id_card_data[2] = {0};
	char* filename;
	char** _tmp2_;
	char** _tmp3_;
	char** _tmp4_ = NULL;
	char** _tmp5_;
	gint _tmp5__length1;
	char** _tmp6_;
	char* _tmp7_;
	char* _tmp8_;
	GdkPixbuf* _tmp9_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	id_card = id_card_new ();
	text = NULL;
	filename = g_build_filename (g_get_home_dir (), ".gss_eap_id", NULL);
	{
		char* _tmp0_ = NULL;
		char* _tmp1_;
		g_file_get_contents (filename, &_tmp0_, NULL, &_inner_error_);
		text = (_tmp1_ = _tmp0_, _g_free0 (text), _tmp1_);
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			result = NULL;
			_g_error_free0 (e);
			_g_free0 (filename);
			_vala_array_destroy (id_card_data, 2, (GDestroyNotify) g_free);
			_g_free0 (text);
			_g_object_unref0 (id_card);
			return result;
		}
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_free0 (filename);
		_vala_array_destroy (id_card_data, 2, (GDestroyNotify) g_free);
		_g_free0 (text);
		_g_object_unref0 (id_card);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	if (_vala_strcmp0 (text, "") == 0) {
		result = NULL;
		_g_free0 (filename);
		_vala_array_destroy (id_card_data, 2, (GDestroyNotify) g_free);
		_g_free0 (text);
		_g_object_unref0 (id_card);
		return result;
	}
	memcpy (id_card_data, _tmp2_ = g_strsplit (text, "\n", 2), 2 * sizeof (char*));
	if (_vala_strcmp0 (id_card_data[1], "") != 0) {
		id_card_set_password (id_card, id_card_data[1]);
	}
	memcpy (id_card_data, _tmp3_ = g_strsplit (id_card_data[0], "@", 2), 2 * sizeof (char*));
	id_card_set_username (id_card, id_card_data[0]);
	id_card_set_issuer (id_card, id_card_data[1]);
	_tmp6_ = (_tmp5_ = (_tmp4_ = g_new0 (char*, 3 + 1), _tmp4_[0] = g_strdup ("email"), _tmp4_[1] = g_strdup ("jabber"), _tmp4_[2] = g_strdup ("irc"), _tmp4_), _tmp5__length1 = 3, _tmp5_);
	id_card_set_services (id_card, _tmp6_, 3);
	_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
	id_card_set_nai (id_card, _tmp8_ = g_strconcat (_tmp7_ = g_strconcat (id_card_get_username (id_card), "@", NULL), id_card_get_issuer (id_card), NULL));
	_g_free0 (_tmp8_);
	_g_free0 (_tmp7_);
	id_card_set_pixbuf (id_card, _tmp9_ = find_icon ("avatar-default", 48));
	_g_object_unref0 (_tmp9_);
	result = id_card;
	_g_free0 (filename);
	_vala_array_destroy (id_card_data, 2, (GDestroyNotify) g_free);
	_g_free0 (text);
	return result;
}


void identities_manager_store_gss_eap_id_file (IdentitiesManager* self, IdCard* id_card) {
	char* text;
	char* filename;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	text = g_strdup ("");
	if (id_card != NULL) {
		char* _tmp0_;
		char* _tmp1_;
		char* _tmp2_;
		char* _tmp3_;
		text = (_tmp3_ = g_strconcat (_tmp2_ = g_strconcat (_tmp1_ = g_strconcat (_tmp0_ = g_strconcat (id_card_get_username (id_card), "@", NULL), id_card_get_issuer (id_card), NULL), "\n", NULL), id_card_get_password (id_card), NULL), _g_free0 (text), _tmp3_);
		_g_free0 (_tmp2_);
		_g_free0 (_tmp1_);
		_g_free0 (_tmp0_);
	}
	filename = g_build_filename (g_get_home_dir (), ".gss_eap_id", NULL);
	{
		g_file_set_contents (filename, text, (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stdout, "Error:  %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_free0 (filename);
		_g_free0 (text);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (filename);
	_g_free0 (text);
}


static void identities_manager_class_init (IdentitiesManagerClass * klass) {
	identities_manager_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = identities_manager_finalize;
}


static void identities_manager_instance_init (IdentitiesManager * self) {
}


static void identities_manager_finalize (GObject* obj) {
	IdentitiesManager * self;
	self = IDENTITIES_MANAGER (obj);
	__g_slist_free_g_object_unref0 (self->id_card_list);
	G_OBJECT_CLASS (identities_manager_parent_class)->finalize (obj);
}


GType identities_manager_get_type (void) {
	static volatile gsize identities_manager_type_id__volatile = 0;
	if (g_once_init_enter (&identities_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IdentitiesManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) identities_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IdentitiesManager), 0, (GInstanceInitFunc) identities_manager_instance_init, NULL };
		GType identities_manager_type_id;
		identities_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "IdentitiesManager", &g_define_type_info, 0);
		g_once_init_leave (&identities_manager_type_id__volatile, identities_manager_type_id);
	}
	return identities_manager_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




