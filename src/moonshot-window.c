/* moonshot-window.c generated by valac 0.10.4, the Vala compiler
 * generated from moonshot-window.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <gdk/gdk.h>
#include <glib/gi18n-lib.h>
#include <pango/pango.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <atk/atk.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus.h>
#include <config.h>


#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
typedef struct _MainWindowPrivate MainWindowPrivate;

#define TYPE_IDENTITIES_MANAGER (identities_manager_get_type ())
#define IDENTITIES_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDENTITIES_MANAGER, IdentitiesManager))
#define IDENTITIES_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDENTITIES_MANAGER, IdentitiesManagerClass))
#define IS_IDENTITIES_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDENTITIES_MANAGER))
#define IS_IDENTITIES_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDENTITIES_MANAGER))
#define IDENTITIES_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDENTITIES_MANAGER, IdentitiesManagerClass))

typedef struct _IdentitiesManager IdentitiesManager;
typedef struct _IdentitiesManagerClass IdentitiesManagerClass;

#define TYPE_IDENTITY_REQUEST (identity_request_get_type ())
#define IDENTITY_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IDENTITY_REQUEST, IdentityRequest))
#define IDENTITY_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IDENTITY_REQUEST, IdentityRequestClass))
#define IS_IDENTITY_REQUEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IDENTITY_REQUEST))
#define IS_IDENTITY_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IDENTITY_REQUEST))
#define IDENTITY_REQUEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IDENTITY_REQUEST, IdentityRequestClass))

typedef struct _IdentityRequest IdentityRequest;
typedef struct _IdentityRequestClass IdentityRequestClass;

#define TYPE_CUSTOM_VBOX (custom_vbox_get_type ())
#define CUSTOM_VBOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CUSTOM_VBOX, CustomVBox))
#define CUSTOM_VBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CUSTOM_VBOX, CustomVBoxClass))
#define IS_CUSTOM_VBOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_VBOX))
#define IS_CUSTOM_VBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CUSTOM_VBOX))
#define CUSTOM_VBOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CUSTOM_VBOX, CustomVBoxClass))

typedef struct _CustomVBox CustomVBox;
typedef struct _CustomVBoxClass CustomVBoxClass;

#define TYPE_ID_CARD (id_card_get_type ())
#define ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ID_CARD, IdCard))
#define ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ID_CARD, IdCardClass))
#define IS_ID_CARD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ID_CARD))
#define IS_ID_CARD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ID_CARD))
#define ID_CARD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ID_CARD, IdCardClass))

typedef struct _IdCard IdCard;
typedef struct _IdCardClass IdCardClass;

#define TYPE_MOONSHOT_SERVER (moonshot_server_get_type ())
#define MOONSHOT_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MOONSHOT_SERVER, MoonshotServer))
#define MOONSHOT_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MOONSHOT_SERVER, MoonshotServerClass))
#define IS_MOONSHOT_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MOONSHOT_SERVER))
#define IS_MOONSHOT_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MOONSHOT_SERVER))
#define MOONSHOT_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MOONSHOT_SERVER, MoonshotServerClass))

typedef struct _MoonshotServer MoonshotServer;
typedef struct _MoonshotServerClass MoonshotServerClass;

#define MAIN_WINDOW_TYPE_COLUMNS (main_window_columns_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_slist_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_slist_free_g_object_unref (var), NULL)))
#define _g_queue_free0(var) ((var == NULL) ? NULL : (var = (g_queue_free (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _IdentitiesManagerPrivate IdentitiesManagerPrivate;

#define TYPE_ID_CARD_WIDGET (id_card_widget_get_type ())
#define ID_CARD_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ID_CARD_WIDGET, IdCardWidget))
#define ID_CARD_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ID_CARD_WIDGET, IdCardWidgetClass))
#define IS_ID_CARD_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ID_CARD_WIDGET))
#define IS_ID_CARD_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ID_CARD_WIDGET))
#define ID_CARD_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ID_CARD_WIDGET, IdCardWidgetClass))

typedef struct _IdCardWidget IdCardWidget;
typedef struct _IdCardWidgetClass IdCardWidgetClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

#define TYPE_ADD_IDENTITY_DIALOG (add_identity_dialog_get_type ())
#define ADD_IDENTITY_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ADD_IDENTITY_DIALOG, AddIdentityDialog))
#define ADD_IDENTITY_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ADD_IDENTITY_DIALOG, AddIdentityDialogClass))
#define IS_ADD_IDENTITY_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ADD_IDENTITY_DIALOG))
#define IS_ADD_IDENTITY_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ADD_IDENTITY_DIALOG))
#define ADD_IDENTITY_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ADD_IDENTITY_DIALOG, AddIdentityDialogClass))

typedef struct _AddIdentityDialog AddIdentityDialog;
typedef struct _AddIdentityDialogClass AddIdentityDialogClass;
typedef struct _IdentityRequestPrivate IdentityRequestPrivate;
#define __g_slist_free_g_free0(var) ((var == NULL) ? NULL : (var = (_g_slist_free_g_free (var), NULL)))

#define TYPE_RULE (rule_get_type ())
typedef struct _Rule Rule;
typedef struct _Block4Data Block4Data;
#define _g_pattern_spec_free0(var) ((var == NULL) ? NULL : (var = (g_pattern_spec_free (var), NULL)))

#define TYPE_ADD_PASSWORD_DIALOG (add_password_dialog_get_type ())
#define ADD_PASSWORD_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ADD_PASSWORD_DIALOG, AddPasswordDialog))
#define ADD_PASSWORD_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ADD_PASSWORD_DIALOG, AddPasswordDialogClass))
#define IS_ADD_PASSWORD_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ADD_PASSWORD_DIALOG))
#define IS_ADD_PASSWORD_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ADD_PASSWORD_DIALOG))
#define ADD_PASSWORD_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ADD_PASSWORD_DIALOG, AddPasswordDialogClass))

typedef struct _AddPasswordDialog AddPasswordDialog;
typedef struct _AddPasswordDialogClass AddPasswordDialogClass;
#define _pango_font_description_free0(var) ((var == NULL) ? NULL : (var = (pango_font_description_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
typedef struct _DBusObjectVTable _DBusObjectVTable;

struct _MainWindow {
	GtkWindow parent_instance;
	MainWindowPrivate * priv;
	IdentitiesManager* identities_manager;
	GQueue* request_queue;
};

struct _MainWindowClass {
	GtkWindowClass parent_class;
};

struct _MainWindowPrivate {
	GtkUIManager* ui_manager;
	GtkEntry* search_entry;
	GtkVBox* vbox_right;
	CustomVBox* custom_vbox;
	GtkVBox* services_internal_vbox;
	GtkEntry* username_entry;
	GtkEntry* password_entry;
	GtkListStore* listmodel;
	GtkTreeModelFilter* filter;
	GSList* candidates;
	MoonshotServer* ipc_server;
	IdCard* default_id_card;
	GHashTable* service_button_map;
};

typedef enum  {
	MAIN_WINDOW_COLUMNS_IDCARD_COL,
	MAIN_WINDOW_COLUMNS_LOGO_COL,
	MAIN_WINDOW_COLUMNS_ISSUER_COL,
	MAIN_WINDOW_COLUMNS_USERNAME_COL,
	MAIN_WINDOW_COLUMNS_PASSWORD_COL,
	MAIN_WINDOW_COLUMNS_N_COLUMNS
} MainWindowColumns;

struct _IdentitiesManager {
	GObject parent_instance;
	IdentitiesManagerPrivate * priv;
	GSList* id_card_list;
};

struct _IdentitiesManagerClass {
	GObjectClass parent_class;
};

struct _IdentityRequest {
	GObject parent_instance;
	IdentityRequestPrivate * priv;
	IdCard* id_card;
	gboolean complete;
	gboolean select_default;
	char* nai;
	char* password;
	char* service;
};

struct _IdentityRequestClass {
	GObjectClass parent_class;
};

struct _Rule {
	char* pattern;
	char* always_confirm;
};

struct _Block4Data {
	int _ref_count_;
	MainWindow * self;
	IdCard* identity;
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};


static gpointer main_window_parent_class = NULL;

GType main_window_get_type (void) G_GNUC_CONST;
GType identities_manager_get_type (void) G_GNUC_CONST;
GType identity_request_get_type (void) G_GNUC_CONST;
GType custom_vbox_get_type (void) G_GNUC_CONST;
GType id_card_get_type (void) G_GNUC_CONST;
GType moonshot_server_get_type (void) G_GNUC_CONST;
#define MAIN_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MAIN_WINDOW, MainWindowPrivate))
enum  {
	MAIN_WINDOW_DUMMY_PROPERTY
};
static GType main_window_columns_get_type (void) G_GNUC_UNUSED;
static void _g_slist_free_g_object_unref (GSList* self);
#define MAIN_WINDOW_WINDOW_WIDTH 400
#define MAIN_WINDOW_WINDOW_HEIGHT 500
#define MAIN_WINDOW_layout "\n" \
"<menubar name='MenuBar'>\n" \
"        <menu name='FileMenu' action='FileMenuAction'>\n" \
"            <menuitem name='AddIdCard' action='AddIdCardAction' />\n" \
"            <separator />\n" \
"            <menuitem name='Quit' action='QuitAction' />\n" \
"        </menu>\n" \
"\n" \
"        <menu name='HelpMenu' action='HelpMenuAction'>\n" \
"             <menuitem name='About' action='AboutAction' />\n" \
"        </menu>\n" \
"</menubar>\n"
MainWindow* main_window_new (void);
MainWindow* main_window_construct (GType object_type);
static void main_window_build_ui (MainWindow* self);
static void main_window_setup_identities_list (MainWindow* self);
static void main_window_load_id_cards (MainWindow* self);
static void main_window_connect_signals (MainWindow* self);
static void main_window_init_ipc_server (MainWindow* self);
void main_window_add_candidate (MainWindow* self, IdCard* idcard);
static gboolean main_window_visible_func (MainWindow* self, GtkTreeModel* model, GtkTreeIter* iter);
const char* id_card_get_issuer (IdCard* self);
const char* id_card_get_display_name (IdCard* self);
char** id_card_get_services (IdCard* self, int* result_length1);
static gboolean _main_window_visible_func_gtk_tree_model_filter_visible_func (GtkTreeModel* model, GtkTreeIter* iter, gpointer self);
static void main_window_search_entry_icon_press_cb (MainWindow* self, GtkEntryIconPosition pos, GdkEvent* event);
static void main_window_search_entry_text_changed_cb (MainWindow* self);
static void main_window_redraw_id_card_widgets (MainWindow* self);
static gboolean main_window_search_entry_key_press_event_cb (MainWindow* self, GdkEventKey* e);
IdentitiesManager* identities_manager_new (void);
IdentitiesManager* identities_manager_construct (GType object_type);
static void main_window_add_id_card_data (MainWindow* self, IdCard* id_card);
static void main_window_add_id_card_widget (MainWindow* self, IdCard* id_card);
GType id_card_widget_get_type (void) G_GNUC_CONST;
static void main_window_fill_details (MainWindow* self, IdCardWidget* id_card_widget);
IdCard* id_card_widget_get_id_card (IdCardWidget* self);
const char* id_card_get_username (IdCard* self);
const char* id_card_get_password (IdCard* self);
static void main_window_fill_services_vbox (MainWindow* self, IdCard* id_card);
void identities_manager_store_id_cards (IdentitiesManager* self);
static void main_window_show_details (MainWindow* self, IdCard* id_card);
static void main_window_details_identity_cb (MainWindow* self, IdCardWidget* id_card_widget);
GType add_identity_dialog_get_type (void) G_GNUC_CONST;
static IdCard* main_window_get_id_card_data (MainWindow* self, AddIdentityDialog* dialog);
IdCard* id_card_new (void);
IdCard* id_card_construct (GType object_type);
const char* add_identity_dialog_get_display_name (AddIdentityDialog* self);
void id_card_set_display_name (IdCard* self, const char* value);
const char* add_identity_dialog_get_issuer (AddIdentityDialog* self);
void id_card_set_issuer (IdCard* self, const char* value);
const char* add_identity_dialog_get_username (AddIdentityDialog* self);
void id_card_set_username (IdCard* self, const char* value);
const char* add_identity_dialog_get_password (AddIdentityDialog* self);
void id_card_set_password (IdCard* self, const char* value);
void id_card_set_services (IdCard* self, char** value, int value_length1);
GdkPixbuf* find_icon (const char* name, gint size);
static void main_window_remove_id_card_data (MainWindow* self, IdCard* id_card);
IdCardWidget* id_card_widget_new (IdCard* id_card);
IdCardWidget* id_card_widget_construct (GType object_type, IdCard* id_card);
void custom_vbox_add_id_card_widget (CustomVBox* self, IdCardWidget* id_card_widget);
static void _main_window_details_identity_cb_id_card_widget_details_id (IdCardWidget* _sender, gpointer self);
static void main_window_remove_identity_cb (MainWindow* self, IdCardWidget* id_card_widget);
static void _main_window_remove_identity_cb_id_card_widget_remove_id (IdCardWidget* _sender, gpointer self);
static void _lambda2_ (IdCardWidget* w, MainWindow* self);
void main_window_send_identity_cb (MainWindow* self, IdCard* identity);
static void __lambda2__id_card_widget_send_id (IdCardWidget* _sender, gpointer self);
void custom_vbox_receive_expanded_event (CustomVBox* self, IdCardWidget* id_card_widget);
static void _custom_vbox_receive_expanded_event_id_card_widget_expanded (IdCardWidget* _sender, gpointer self);
static void _main_window_fill_details_id_card_widget_expanded (IdCardWidget* _sender, gpointer self);
gboolean main_window_display_name_is_valid (MainWindow* self, const char* name, char** candidate);
void main_window_insert_id_card (MainWindow* self, IdCard* id_card);
gboolean main_window_add_identity (MainWindow* self, IdCard* id_card);
static void main_window_add_identity_manual_cb (MainWindow* self);
AddIdentityDialog* add_identity_dialog_new (void);
AddIdentityDialog* add_identity_dialog_construct (GType object_type);
static void main_window_remove_id_card_widget (MainWindow* self, IdCardWidget* id_card_widget);
void custom_vbox_remove_id_card_widget (CustomVBox* self, IdCardWidget* id_card_widget);
static void main_window_remove_identity (MainWindow* self, IdCardWidget* id_card_widget);
void main_window_select_identity (MainWindow* self, IdentityRequest* request);
IdCardWidget* custom_vbox_get_current_idcard (CustomVBox* self);
GtkButton* id_card_widget_get_send_button (IdCardWidget* self);
const char* id_card_get_nai (IdCard* self);
static void _g_slist_free_g_free (GSList* self);
GType rule_get_type (void) G_GNUC_CONST;
Rule* rule_dup (const Rule* self);
void rule_free (Rule* self);
void rule_copy (const Rule* self, Rule* dest);
void rule_destroy (Rule* self);
Rule* id_card_get_rules (IdCard* self, int* result_length1);
static gboolean main_window_match_service_pattern (MainWindow* self, const char* service, const char* pattern);
static gboolean _lambda3_ (Block4Data* _data4_);
static gboolean __lambda3__gsource_func (gpointer self);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (Block4Data* _data4_);
AddPasswordDialog* add_password_dialog_new (void);
AddPasswordDialog* add_password_dialog_construct (GType object_type);
GType add_password_dialog_get_type (void) G_GNUC_CONST;
const char* add_password_dialog_get_password (AddPasswordDialog* self);
gboolean add_password_dialog_get_remember (AddPasswordDialog* self);
void identity_request_return_identity (IdentityRequest* self, IdCard* id_card);
static void main_window_label_make_bold (MainWindow* self, GtkLabel* label);
static void _lambda1_ (GtkButton* remove_button, MainWindow* self);
void id_card_widget_update_id_card_label (IdCardWidget* self);
static void __lambda1__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void main_window_on_about_action (MainWindow* self);
static GtkActionEntry* main_window_create_actions (MainWindow* self, int* result_length1);
static void _vala_array_add1 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _main_window_add_identity_manual_cb_gtk_action_callback (GtkAction* action, gpointer self);
static void _vala_array_add2 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _gtk_main_quit_gtk_action_callback (GtkAction* action, gpointer self);
static void _vala_array_add3 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _vala_array_add4 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void _main_window_on_about_action_gtk_action_callback (GtkAction* action, gpointer self);
static void _vala_array_add5 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value);
static void main_window_create_ui_manager (MainWindow* self);
static void main_window_set_atk_name_description (MainWindow* self, GtkWidget* widget, const char* name, const char* description);
GdkPixbuf* find_icon_sized (const char* name, GtkIconSize icon_size);
static void _main_window_search_entry_icon_press_cb_gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self);
static void _main_window_search_entry_text_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static gboolean _main_window_search_entry_key_press_event_cb_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
CustomVBox* custom_vbox_new (MainWindow* window, gboolean homogeneous, gint spacing);
CustomVBox* custom_vbox_construct (GType object_type, MainWindow* window, gboolean homogeneous, gint spacing);
static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self);
static guint _dynamic_request_name0 (DBusGProxy* self, const char* param1, guint param2, GError** error);
MoonshotServer* moonshot_server_new (GtkWindow* window);
MoonshotServer* moonshot_server_construct (GType object_type, GtkWindow* window);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
gint main_window_main (char** args, int args_length1);
static void main_window_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);



static GType main_window_columns_get_type (void) {
	static volatile gsize main_window_columns_type_id__volatile = 0;
	if (g_once_init_enter (&main_window_columns_type_id__volatile)) {
		static const GEnumValue values[] = {{MAIN_WINDOW_COLUMNS_IDCARD_COL, "MAIN_WINDOW_COLUMNS_IDCARD_COL", "idcard-col"}, {MAIN_WINDOW_COLUMNS_LOGO_COL, "MAIN_WINDOW_COLUMNS_LOGO_COL", "logo-col"}, {MAIN_WINDOW_COLUMNS_ISSUER_COL, "MAIN_WINDOW_COLUMNS_ISSUER_COL", "issuer-col"}, {MAIN_WINDOW_COLUMNS_USERNAME_COL, "MAIN_WINDOW_COLUMNS_USERNAME_COL", "username-col"}, {MAIN_WINDOW_COLUMNS_PASSWORD_COL, "MAIN_WINDOW_COLUMNS_PASSWORD_COL", "password-col"}, {MAIN_WINDOW_COLUMNS_N_COLUMNS, "MAIN_WINDOW_COLUMNS_N_COLUMNS", "n-columns"}, {0, NULL, NULL}};
		GType main_window_columns_type_id;
		main_window_columns_type_id = g_enum_register_static ("MainWindowColumns", values);
		g_once_init_leave (&main_window_columns_type_id__volatile, main_window_columns_type_id);
	}
	return main_window_columns_type_id__volatile;
}


static void _g_slist_free_g_object_unref (GSList* self) {
	g_slist_foreach (self, (GFunc) g_object_unref, NULL);
	g_slist_free (self);
}


MainWindow* main_window_construct (GType object_type) {
	MainWindow * self;
	GQueue* _tmp0_;
	GHashTable* _tmp1_;
	self = g_object_newv (object_type, 0, NULL);
	self->request_queue = (_tmp0_ = g_queue_new (), _g_queue_free0 (self->request_queue), _tmp0_);
	self->priv->service_button_map = (_tmp1_ = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, g_free), _g_hash_table_unref0 (self->priv->service_button_map), _tmp1_);
	gtk_window_set_title ((GtkWindow*) self, "Moonshoot");
	gtk_window_set_position ((GtkWindow*) self, GTK_WIN_POS_CENTER);
	gtk_window_set_default_size ((GtkWindow*) self, MAIN_WINDOW_WINDOW_WIDTH, MAIN_WINDOW_WINDOW_HEIGHT);
	main_window_build_ui (self);
	main_window_setup_identities_list (self);
	main_window_load_id_cards (self);
	main_window_connect_signals (self);
	main_window_init_ipc_server (self);
	return self;
}


MainWindow* main_window_new (void) {
	return main_window_construct (TYPE_MAIN_WINDOW);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void main_window_add_candidate (MainWindow* self, IdCard* idcard) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (idcard != NULL);
	self->priv->candidates = g_slist_append (self->priv->candidates, _g_object_ref0 (idcard));
}


static gboolean string_contains (const char* self, const char* needle) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	result = strstr (self, needle) != NULL;
	return result;
}


static gboolean main_window_visible_func (MainWindow* self, GtkTreeModel* model, GtkTreeIter* iter) {
	gboolean result = FALSE;
	IdCard* id_card;
	char* entry_text;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (model != NULL, FALSE);
	id_card = NULL;
	gtk_tree_model_get (model, iter, MAIN_WINDOW_COLUMNS_IDCARD_COL, &id_card, -1);
	if (id_card == NULL) {
		result = FALSE;
		_g_object_unref0 (id_card);
		return result;
	}
	if (self->priv->candidates != NULL) {
		gboolean is_candidate;
		is_candidate = FALSE;
		{
			GSList* candidate_collection;
			GSList* candidate_it;
			candidate_collection = self->priv->candidates;
			for (candidate_it = candidate_collection; candidate_it != NULL; candidate_it = candidate_it->next) {
				IdCard* candidate;
				candidate = _g_object_ref0 ((IdCard*) candidate_it->data);
				{
					if (candidate == id_card) {
						is_candidate = TRUE;
					}
					_g_object_unref0 (candidate);
				}
			}
		}
		if (!is_candidate) {
			result = FALSE;
			_g_object_unref0 (id_card);
			return result;
		}
	}
	entry_text = g_strdup (gtk_entry_get_text (self->priv->search_entry));
	if (entry_text == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = _vala_strcmp0 (entry_text, "") == 0;
	}
	if (_tmp0_) {
		result = TRUE;
		_g_free0 (entry_text);
		_g_object_unref0 (id_card);
		return result;
	}
	{
		char** _tmp1_;
		char** search_text_collection;
		int search_text_collection_length1;
		int search_text_it;
		search_text_collection = _tmp1_ = g_strsplit (entry_text, " ", 0);
		search_text_collection_length1 = _vala_array_length (_tmp1_);
		for (search_text_it = 0; search_text_it < _vala_array_length (_tmp1_); search_text_it = search_text_it + 1) {
			char* search_text;
			search_text = g_strdup (search_text_collection[search_text_it]);
			{
				char* search_text_casefold;
				gint _tmp2_;
				if (_vala_strcmp0 (search_text, "") == 0) {
					_g_free0 (search_text);
					continue;
				}
				search_text_casefold = g_utf8_casefold (search_text, -1);
				if (id_card_get_issuer (id_card) != NULL) {
					char* issuer_casefold;
					issuer_casefold = g_strdup (id_card_get_issuer (id_card));
					if (string_contains (issuer_casefold, search_text_casefold)) {
						result = TRUE;
						_g_free0 (issuer_casefold);
						_g_free0 (search_text_casefold);
						_g_free0 (search_text);
						search_text_collection = (_vala_array_free (search_text_collection, search_text_collection_length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (entry_text);
						_g_object_unref0 (id_card);
						return result;
					}
					_g_free0 (issuer_casefold);
				}
				if (id_card_get_display_name (id_card) != NULL) {
					char* display_name_casefold;
					display_name_casefold = g_utf8_casefold (id_card_get_display_name (id_card), -1);
					if (string_contains (display_name_casefold, search_text_casefold)) {
						result = TRUE;
						_g_free0 (display_name_casefold);
						_g_free0 (search_text_casefold);
						_g_free0 (search_text);
						search_text_collection = (_vala_array_free (search_text_collection, search_text_collection_length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (entry_text);
						_g_object_unref0 (id_card);
						return result;
					}
					_g_free0 (display_name_casefold);
				}
				if (_tmp2_ > 0) {
					{
						gint _tmp3_;
						char** service_collection;
						int service_collection_length1;
						int service_it;
						service_collection = id_card_get_services (id_card, &_tmp3_);
						service_collection_length1 = _tmp3_;
						for (service_it = 0; service_it < _tmp3_; service_it = service_it + 1) {
							char* service;
							service = g_strdup (service_collection[service_it]);
							{
								char* service_casefold;
								service_casefold = g_utf8_casefold (service, -1);
								if (string_contains (service_casefold, search_text_casefold)) {
									result = TRUE;
									_g_free0 (service_casefold);
									_g_free0 (service);
									_g_free0 (search_text_casefold);
									_g_free0 (search_text);
									search_text_collection = (_vala_array_free (search_text_collection, search_text_collection_length1, (GDestroyNotify) g_free), NULL);
									_g_free0 (entry_text);
									_g_object_unref0 (id_card);
									return result;
								}
								_g_free0 (service_casefold);
								_g_free0 (service);
							}
						}
					}
				}
				_g_free0 (search_text_casefold);
				_g_free0 (search_text);
			}
		}
		search_text_collection = (_vala_array_free (search_text_collection, search_text_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	result = FALSE;
	_g_free0 (entry_text);
	_g_object_unref0 (id_card);
	return result;
}


static gboolean _main_window_visible_func_gtk_tree_model_filter_visible_func (GtkTreeModel* model, GtkTreeIter* iter, gpointer self) {
	gboolean result;
	result = main_window_visible_func (self, model, iter);
	return result;
}


static void main_window_setup_identities_list (MainWindow* self) {
	GtkListStore* _tmp0_;
	GtkTreeModelFilter* _tmp1_;
	g_return_if_fail (self != NULL);
	self->priv->listmodel = (_tmp0_ = gtk_list_store_new ((gint) MAIN_WINDOW_COLUMNS_N_COLUMNS, TYPE_ID_CARD, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING), _g_object_unref0 (self->priv->listmodel), _tmp0_);
	self->priv->filter = (_tmp1_ = (GtkTreeModelFilter*) gtk_tree_model_filter_new ((GtkTreeModel*) self->priv->listmodel, NULL), _g_object_unref0 (self->priv->filter), _tmp1_);
	gtk_tree_model_filter_set_visible_func (self->priv->filter, _main_window_visible_func_gtk_tree_model_filter_visible_func, g_object_ref (self), g_object_unref);
}


static void main_window_search_entry_icon_press_cb (MainWindow* self, GtkEntryIconPosition pos, GdkEvent* event) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	if (pos == GTK_ENTRY_ICON_PRIMARY) {
		g_print ("Search entry icon pressed\n");
	} else {
		gtk_entry_set_text (self->priv->search_entry, "");
	}
}


static void main_window_search_entry_text_changed_cb (MainWindow* self) {
	gboolean has_text;
	g_return_if_fail (self != NULL);
	gtk_tree_model_filter_refilter (self->priv->filter);
	main_window_redraw_id_card_widgets (self);
	has_text = gtk_entry_get_text_length (self->priv->search_entry) > 0;
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, has_text);
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, has_text);
	gtk_widget_set_visible ((GtkWidget*) self->priv->vbox_right, FALSE);
}


static gboolean main_window_search_entry_key_press_event_cb (MainWindow* self, GdkEventKey* e) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (_vala_strcmp0 (gdk_keyval_name ((*e).keyval), "Escape") == 0) {
		gtk_entry_set_text (self->priv->search_entry, "");
	}
	result = FALSE;
	return result;
}


static void main_window_load_id_cards (MainWindow* self) {
	IdentitiesManager* _tmp0_;
	IdCard* _tmp1_;
	g_return_if_fail (self != NULL);
	self->identities_manager = (_tmp0_ = identities_manager_new (), _g_object_unref0 (self->identities_manager), _tmp0_);
	if (self->identities_manager->id_card_list == NULL) {
		return;
	}
	{
		GSList* id_card_collection;
		GSList* id_card_it;
		id_card_collection = self->identities_manager->id_card_list;
		for (id_card_it = id_card_collection; id_card_it != NULL; id_card_it = id_card_it->next) {
			IdCard* id_card;
			id_card = _g_object_ref0 ((IdCard*) id_card_it->data);
			{
				main_window_add_id_card_data (self, id_card);
				main_window_add_id_card_widget (self, id_card);
				_g_object_unref0 (id_card);
			}
		}
	}
	self->priv->default_id_card = (_tmp1_ = _g_object_ref0 ((IdCard*) self->identities_manager->id_card_list->data), _g_object_unref0 (self->priv->default_id_card), _tmp1_);
}


static void main_window_fill_details (MainWindow* self, IdCardWidget* id_card_widget) {
	IdCard* id_card;
	char* _tmp0_;
	GList* children;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	id_card = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	gtk_entry_set_text (self->priv->username_entry, id_card_get_username (id_card));
	_tmp0_ = g_strdup (id_card_get_password (id_card));
	if (_tmp0_ == NULL) {
		char* _tmp1_;
		_tmp0_ = (_tmp1_ = g_strdup (""), _g_free0 (_tmp0_), _tmp1_);
	}
	gtk_entry_set_text (self->priv->password_entry, _tmp0_);
	children = gtk_container_get_children ((GtkContainer*) self->priv->services_internal_vbox);
	{
		GList* hbox_collection;
		GList* hbox_it;
		hbox_collection = children;
		for (hbox_it = hbox_collection; hbox_it != NULL; hbox_it = hbox_it->next) {
			GtkWidget* hbox;
			hbox = (GtkWidget*) hbox_it->data;
			{
				gtk_object_destroy ((GtkObject*) hbox);
			}
		}
	}
	main_window_fill_services_vbox (self, id_card_widget_get_id_card (id_card_widget));
	identities_manager_store_id_cards (self->identities_manager);
	_g_list_free0 (children);
	_g_free0 (_tmp0_);
	_g_object_unref0 (id_card);
}


static void main_window_show_details (MainWindow* self, IdCard* id_card) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	gtk_widget_set_visible ((GtkWidget*) self->priv->vbox_right, !gtk_widget_get_visible ((GtkWidget*) self->priv->vbox_right));
	if (gtk_widget_get_visible ((GtkWidget*) self->priv->vbox_right) == FALSE) {
		gtk_window_resize ((GtkWindow*) self, MAIN_WINDOW_WINDOW_WIDTH, MAIN_WINDOW_WINDOW_HEIGHT);
	}
}


static void main_window_details_identity_cb (MainWindow* self, IdCardWidget* id_card_widget) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	main_window_fill_details (self, id_card_widget);
	main_window_show_details (self, id_card_widget_get_id_card (id_card_widget));
}


static IdCard* main_window_get_id_card_data (MainWindow* self, AddIdentityDialog* dialog) {
	IdCard* result = NULL;
	IdCard* id_card;
	char** _tmp0_ = NULL;
	char** _tmp1_;
	gint _tmp1__length1;
	char** _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (dialog != NULL, NULL);
	id_card = id_card_new ();
	id_card_set_display_name (id_card, add_identity_dialog_get_display_name (dialog));
	id_card_set_issuer (id_card, add_identity_dialog_get_issuer (dialog));
	if (_vala_strcmp0 (id_card_get_issuer (id_card), "") == 0) {
		id_card_set_issuer (id_card, "Issuer");
	}
	id_card_set_username (id_card, add_identity_dialog_get_username (dialog));
	id_card_set_password (id_card, add_identity_dialog_get_password (dialog));
	_tmp2_ = (_tmp1_ = (_tmp0_ = g_new0 (char*, 0 + 1), _tmp0_), _tmp1__length1 = 0, _tmp1_);
	id_card_set_services (id_card, _tmp2_, 0);
	_tmp1_ = (_vala_array_free (_tmp1_, _tmp1__length1, (GDestroyNotify) g_free), NULL);
	g_object_set_data_full ((GObject*) id_card, "pixbuf", find_icon ("avatar-default", 48), g_object_unref);
	result = id_card;
	return result;
}


static void main_window_add_id_card_data (MainWindow* self, IdCard* id_card) {
	GtkTreeIter iter = {0};
	GdkPixbuf* pixbuf;
	GdkPixbuf* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	pixbuf = NULL;
	gtk_list_store_append (self->priv->listmodel, &iter);
	pixbuf = (_tmp0_ = _g_object_ref0 ((GdkPixbuf*) g_object_get_data ((GObject*) id_card, "pixbuf")), _g_object_unref0 (pixbuf), _tmp0_);
	gtk_list_store_set (self->priv->listmodel, &iter, MAIN_WINDOW_COLUMNS_IDCARD_COL, id_card, MAIN_WINDOW_COLUMNS_LOGO_COL, pixbuf, MAIN_WINDOW_COLUMNS_ISSUER_COL, id_card_get_issuer (id_card), MAIN_WINDOW_COLUMNS_USERNAME_COL, id_card_get_username (id_card), MAIN_WINDOW_COLUMNS_PASSWORD_COL, id_card_get_password (id_card), -1);
	_g_object_unref0 (pixbuf);
}


static void main_window_remove_id_card_data (MainWindow* self, IdCard* id_card) {
	GtkTreeIter iter = {0};
	char* issuer;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	issuer = NULL;
	if (gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->listmodel, &iter)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					if (!gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->listmodel, &iter)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				gtk_tree_model_get ((GtkTreeModel*) self->priv->listmodel, &iter, MAIN_WINDOW_COLUMNS_ISSUER_COL, &issuer, -1);
				if (_vala_strcmp0 (id_card_get_issuer (id_card), issuer) == 0) {
					gtk_list_store_remove (self->priv->listmodel, &iter);
					break;
				}
			}
		}
	}
	_g_free0 (issuer);
}


static void _main_window_details_identity_cb_id_card_widget_details_id (IdCardWidget* _sender, gpointer self) {
	main_window_details_identity_cb (self, _sender);
}


static void _main_window_remove_identity_cb_id_card_widget_remove_id (IdCardWidget* _sender, gpointer self) {
	main_window_remove_identity_cb (self, _sender);
}


static void _lambda2_ (IdCardWidget* w, MainWindow* self) {
	g_return_if_fail (w != NULL);
	main_window_send_identity_cb (self, id_card_widget_get_id_card (w));
}


static void __lambda2__id_card_widget_send_id (IdCardWidget* _sender, gpointer self) {
	_lambda2_ (_sender, self);
}


static void _custom_vbox_receive_expanded_event_id_card_widget_expanded (IdCardWidget* _sender, gpointer self) {
	custom_vbox_receive_expanded_event (self, _sender);
}


static void _main_window_fill_details_id_card_widget_expanded (IdCardWidget* _sender, gpointer self) {
	main_window_fill_details (self, _sender);
}


static void main_window_add_id_card_widget (MainWindow* self, IdCard* id_card) {
	IdCardWidget* id_card_widget;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	id_card_widget = g_object_ref_sink (id_card_widget_new (id_card));
	custom_vbox_add_id_card_widget (self->priv->custom_vbox, id_card_widget);
	g_signal_connect_object (id_card_widget, "details-id", (GCallback) _main_window_details_identity_cb_id_card_widget_details_id, self, 0);
	g_signal_connect_object (id_card_widget, "remove-id", (GCallback) _main_window_remove_identity_cb_id_card_widget_remove_id, self, 0);
	g_signal_connect_object (id_card_widget, "send-id", (GCallback) __lambda2__id_card_widget_send_id, self, 0);
	g_signal_connect_object (id_card_widget, "expanded", (GCallback) _custom_vbox_receive_expanded_event_id_card_widget_expanded, self->priv->custom_vbox, 0);
	g_signal_connect_object (id_card_widget, "expanded", (GCallback) _main_window_fill_details_id_card_widget_expanded, self, 0);
	_g_object_unref0 (id_card_widget);
}


gboolean main_window_display_name_is_valid (MainWindow* self, const char* name, char** candidate) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (name != NULL, FALSE);
	if (candidate != NULL) {
		*candidate = NULL;
	}
	{
		GSList* id_card_collection;
		GSList* id_card_it;
		id_card_collection = self->identities_manager->id_card_list;
		for (id_card_it = id_card_collection; id_card_it != NULL; id_card_it = id_card_it->next) {
			IdCard* id_card;
			id_card = _g_object_ref0 ((IdCard*) id_card_it->data);
			{
				if (_vala_strcmp0 (id_card_get_display_name (id_card), name) == 0) {
					if ((candidate) != NULL) {
						{
							gint i;
							i = 0;
							{
								gboolean _tmp0_;
								_tmp0_ = TRUE;
								while (TRUE) {
									char* tmp;
									if (!_tmp0_) {
										i++;
									}
									_tmp0_ = FALSE;
									if (!(i < 1000)) {
										break;
									}
									tmp = g_strdup_printf ("%s %d", name, i);
									if (main_window_display_name_is_valid (self, tmp, NULL)) {
										char* _tmp1_;
										*candidate = (_tmp1_ = g_strdup (tmp), _g_free0 (*candidate), _tmp1_);
										_g_free0 (tmp);
										break;
									}
									_g_free0 (tmp);
								}
							}
						}
					}
					result = FALSE;
					_g_object_unref0 (id_card);
					return result;
				}
				_g_object_unref0 (id_card);
			}
		}
	}
	result = TRUE;
	return result;
}


void main_window_insert_id_card (MainWindow* self, IdCard* id_card) {
	char* candidate;
	char* _tmp0_ = NULL;
	gboolean _tmp1_;
	char* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	candidate = NULL;
	if (!(_tmp1_ = main_window_display_name_is_valid (self, id_card_get_display_name (id_card), &_tmp0_), candidate = (_tmp2_ = _tmp0_, _g_free0 (candidate), _tmp2_), _tmp1_)) {
		id_card_set_display_name (id_card, candidate);
	}
	self->identities_manager->id_card_list = g_slist_prepend (self->identities_manager->id_card_list, _g_object_ref0 (id_card));
	identities_manager_store_id_cards (self->identities_manager);
	main_window_add_id_card_data (self, id_card);
	main_window_add_id_card_widget (self, id_card);
	_g_free0 (candidate);
}


gboolean main_window_add_identity (MainWindow* self, IdCard* id_card) {
	gboolean result = FALSE;
	GtkMessageDialog* dialog;
	gint ret;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (id_card != NULL, FALSE);
	dialog = g_object_ref_sink ((GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) self, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, _ ("Would you like to add '%s' ID Card to the ID Card Organizer?"), id_card_get_display_name (id_card)));
	gtk_widget_show_all ((GtkWidget*) dialog);
	ret = gtk_dialog_run ((GtkDialog*) dialog);
	gtk_widget_hide ((GtkWidget*) dialog);
	if (ret == GTK_RESPONSE_YES) {
		g_object_set_data_full ((GObject*) id_card, "pixbuf", find_icon ("avatar-default", 48), g_object_unref);
		main_window_insert_id_card (self, id_card);
		result = TRUE;
		_g_object_unref0 (dialog);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (dialog);
	return result;
}


static void main_window_add_identity_manual_cb (MainWindow* self) {
	AddIdentityDialog* dialog;
	gint _result_;
	g_return_if_fail (self != NULL);
	dialog = g_object_ref_sink (add_identity_dialog_new ());
	_result_ = gtk_dialog_run ((GtkDialog*) dialog);
	switch (_result_) {
		case GTK_RESPONSE_OK:
		{
			IdCard* _tmp0_;
			main_window_insert_id_card (self, _tmp0_ = main_window_get_id_card_data (self, dialog));
			_g_object_unref0 (_tmp0_);
			break;
		}
		default:
		{
			break;
		}
	}
	gtk_object_destroy ((GtkObject*) dialog);
	_g_object_unref0 (dialog);
}


static void main_window_remove_id_card_widget (MainWindow* self, IdCardWidget* id_card_widget) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	main_window_remove_id_card_data (self, id_card_widget_get_id_card (id_card_widget));
	custom_vbox_remove_id_card_widget (self->priv->custom_vbox, id_card_widget);
}


static void main_window_remove_identity (MainWindow* self, IdCardWidget* id_card_widget) {
	IdCard* id_card;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	id_card = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	self->identities_manager->id_card_list = g_slist_remove (self->identities_manager->id_card_list, id_card);
	identities_manager_store_id_cards (self->identities_manager);
	main_window_remove_id_card_widget (self, id_card_widget);
	_g_object_unref0 (id_card);
}


static void main_window_redraw_id_card_widgets (MainWindow* self) {
	GtkTreeIter iter = {0};
	IdCard* id_card;
	GList* children;
	g_return_if_fail (self != NULL);
	id_card = NULL;
	children = gtk_container_get_children ((GtkContainer*) self->priv->custom_vbox);
	{
		GList* id_card_widget_collection;
		GList* id_card_widget_it;
		id_card_widget_collection = children;
		for (id_card_widget_it = id_card_widget_collection; id_card_widget_it != NULL; id_card_widget_it = id_card_widget_it->next) {
			GtkWidget* id_card_widget;
			id_card_widget = (GtkWidget*) id_card_widget_it->data;
			{
				gtk_object_destroy ((GtkObject*) id_card_widget);
			}
		}
	}
	if (gtk_tree_model_get_iter_first ((GtkTreeModel*) self->priv->filter, &iter)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					if (!gtk_tree_model_iter_next ((GtkTreeModel*) self->priv->filter, &iter)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				gtk_tree_model_get ((GtkTreeModel*) self->priv->filter, &iter, MAIN_WINDOW_COLUMNS_IDCARD_COL, &id_card, -1);
				main_window_add_id_card_widget (self, id_card);
			}
		}
	}
	_g_list_free0 (children);
	_g_object_unref0 (id_card);
}


static void main_window_remove_identity_cb (MainWindow* self, IdCardWidget* id_card_widget) {
	IdCard* id_card;
	GtkMessageDialog* dialog;
	gint _result_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card_widget != NULL);
	id_card = _g_object_ref0 (id_card_widget_get_id_card (id_card_widget));
	dialog = g_object_ref_sink ((GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_INFO, GTK_BUTTONS_YES_NO, _ ("Are you sure you want to delete %s ID Card?"), id_card_get_issuer (id_card)));
	_result_ = gtk_dialog_run ((GtkDialog*) dialog);
	switch (_result_) {
		case GTK_RESPONSE_YES:
		{
			main_window_remove_identity (self, id_card_widget);
			break;
		}
		default:
		{
			break;
		}
	}
	gtk_object_destroy ((GtkObject*) dialog);
	_g_object_unref0 (dialog);
	_g_object_unref0 (id_card);
}


static void _g_slist_free_g_free (GSList* self) {
	g_slist_foreach (self, (GFunc) g_free, NULL);
	g_slist_free (self);
}


static gboolean _lambda3_ (Block4Data* _data4_) {
	MainWindow * self;
	gboolean result = FALSE;
	self = _data4_->self;
	main_window_send_identity_cb (self, _data4_->identity);
	result = FALSE;
	return result;
}


static gboolean __lambda3__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda3_ (self);
	return result;
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (Block4Data* _data4_) {
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		_g_object_unref0 (_data4_->self);
		_g_object_unref0 (_data4_->identity);
		g_slice_free (Block4Data, _data4_);
	}
}


void main_window_select_identity (MainWindow* self, IdentityRequest* request) {
	Block4Data* _data4_;
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (request != NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_data4_->identity = NULL;
	g_queue_push_tail (self->request_queue, _g_object_ref0 (request));
	if (custom_vbox_get_current_idcard (self->priv->custom_vbox) != NULL) {
		_tmp0_ = id_card_widget_get_send_button (custom_vbox_get_current_idcard (self->priv->custom_vbox)) != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gtk_widget_set_sensitive ((GtkWidget*) id_card_widget_get_send_button (custom_vbox_get_current_idcard (self->priv->custom_vbox)), TRUE);
	}
	if (request->select_default) {
		IdCard* _tmp1_;
		_data4_->identity = (_tmp1_ = _g_object_ref0 (self->priv->default_id_card), _g_object_unref0 (_data4_->identity), _tmp1_);
	}
	if (_data4_->identity == NULL) {
		gboolean _tmp2_ = FALSE;
		gboolean has_nai;
		gboolean _tmp3_ = FALSE;
		gboolean has_srv;
		gboolean confirm;
		IdCard* nai_provided;
		gboolean _tmp7_ = FALSE;
		if (request->nai != NULL) {
			_tmp2_ = _vala_strcmp0 (request->nai, "") != 0;
		} else {
			_tmp2_ = FALSE;
		}
		has_nai = _tmp2_;
		if (request->service != NULL) {
			_tmp3_ = _vala_strcmp0 (request->service, "") != 0;
		} else {
			_tmp3_ = FALSE;
		}
		has_srv = _tmp3_;
		confirm = FALSE;
		nai_provided = NULL;
		{
			GSList* id_collection;
			GSList* id_it;
			id_collection = self->identities_manager->id_card_list;
			for (id_it = id_collection; id_it != NULL; id_it = id_it->next) {
				IdCard* id;
				id = _g_object_ref0 ((IdCard*) id_it->data);
				{
					gboolean _tmp4_ = FALSE;
					if (has_nai) {
						_tmp4_ = _vala_strcmp0 (request->nai, id_card_get_nai (id)) == 0;
					} else {
						_tmp4_ = FALSE;
					}
					if (_tmp4_) {
						IdCard* _tmp5_;
						nai_provided = (_tmp5_ = _g_object_ref0 (id), _g_object_unref0 (nai_provided), _tmp5_);
						main_window_add_candidate (self, id);
						_g_object_unref0 (id);
						continue;
					}
					if (has_srv) {
						{
							gint _tmp6_;
							char** srv_collection;
							int srv_collection_length1;
							int srv_it;
							srv_collection = id_card_get_services (id, &_tmp6_);
							srv_collection_length1 = _tmp6_;
							for (srv_it = 0; srv_it < _tmp6_; srv_it = srv_it + 1) {
								char* srv;
								srv = g_strdup (srv_collection[srv_it]);
								{
									if (_vala_strcmp0 (request->service, srv) == 0) {
										main_window_add_candidate (self, id);
										_g_free0 (srv);
										continue;
									}
									_g_free0 (srv);
								}
							}
						}
					}
					_g_object_unref0 (id);
				}
			}
		}
		if (has_srv) {
			_tmp7_ = g_slist_length (self->priv->candidates) > 1;
		} else {
			_tmp7_ = FALSE;
		}
		if (_tmp7_) {
			{
				GSList* id_collection;
				GSList* id_it;
				id_collection = self->priv->candidates;
				for (id_it = id_collection; id_it != NULL; id_it = id_it->next) {
					IdCard* id;
					id = _g_object_ref0 ((IdCard*) id_it->data);
					{
						gint i;
						GSList* services_list;
						gboolean has_service;
						gint services_length1;
						gint _services_size_;
						char** _tmp13_;
						gint _tmp12_;
						char** services;
						char** _tmp15_;
						i = 0;
						services_list = NULL;
						has_service = FALSE;
						{
							gint _tmp8_;
							char** srv_collection;
							int srv_collection_length1;
							int srv_it;
							srv_collection = id_card_get_services (id, &_tmp8_);
							srv_collection_length1 = _tmp8_;
							for (srv_it = 0; srv_it < _tmp8_; srv_it = srv_it + 1) {
								char* srv;
								srv = g_strdup (srv_collection[srv_it]);
								{
									if (_vala_strcmp0 (srv, request->service) == 0) {
										has_service = TRUE;
										_g_free0 (srv);
										continue;
									}
									services_list = g_slist_append (services_list, g_strdup (srv));
									_g_free0 (srv);
								}
							}
						}
						if (!has_service) {
							__g_slist_free_g_free0 (services_list);
							_g_object_unref0 (id);
							continue;
						}
						if (g_slist_length (services_list) == 0) {
							char** _tmp9_ = NULL;
							char** _tmp10_;
							gint _tmp10__length1;
							char** _tmp11_;
							_tmp11_ = (_tmp10_ = (_tmp9_ = g_new0 (char*, 0 + 1), _tmp9_), _tmp10__length1 = 0, _tmp10_);
							id_card_set_services (id, _tmp11_, 0);
							_tmp10_ = (_vala_array_free (_tmp10_, _tmp10__length1, (GDestroyNotify) g_free), NULL);
							__g_slist_free_g_free0 (services_list);
							_g_object_unref0 (id);
							continue;
						}
						services = (_tmp13_ = g_new0 (char*, (_tmp12_ = g_slist_length (services_list)) + 1), services_length1 = _tmp12_, _services_size_ = services_length1, _tmp13_);
						{
							GSList* srv_collection;
							GSList* srv_it;
							srv_collection = services_list;
							for (srv_it = srv_collection; srv_it != NULL; srv_it = srv_it->next) {
								char* srv;
								srv = g_strdup ((const char*) srv_it->data);
								{
									char* _tmp14_;
									services[i] = (_tmp14_ = g_strdup (srv), _g_free0 (services[i]), _tmp14_);
									i++;
									_g_free0 (srv);
								}
							}
						}
						_tmp15_ = services;
						id_card_set_services (id, _tmp15_, services_length1);
						services = (_vala_array_free (services, services_length1, (GDestroyNotify) g_free), NULL);
						__g_slist_free_g_free0 (services_list);
						_g_object_unref0 (id);
					}
				}
			}
		}
		identities_manager_store_id_cards (self->identities_manager);
		if (g_slist_length (self->priv->candidates) == 0) {
			{
				GSList* id_collection;
				GSList* id_it;
				id_collection = self->identities_manager->id_card_list;
				for (id_it = id_collection; id_it != NULL; id_it = id_it->next) {
					IdCard* id;
					id = _g_object_ref0 ((IdCard*) id_it->data);
					{
						{
							gint _tmp16_;
							Rule* rule_collection;
							int rule_collection_length1;
							int rule_it;
							rule_collection = id_card_get_rules (id, &_tmp16_);
							rule_collection_length1 = _tmp16_;
							for (rule_it = 0; rule_it < _tmp16_; rule_it = rule_it + 1) {
								Rule _tmp17_ = {0};
								Rule rule;
								rule = (rule_copy (&rule_collection[rule_it], &_tmp17_), _tmp17_);
								{
									if (!main_window_match_service_pattern (self, request->service, rule.pattern)) {
										rule_destroy (&rule);
										continue;
									}
									self->priv->candidates = g_slist_append (self->priv->candidates, _g_object_ref0 (id));
									if (_vala_strcmp0 (rule.always_confirm, "true") == 0) {
										confirm = TRUE;
									}
									rule_destroy (&rule);
								}
							}
						}
						_g_object_unref0 (id);
					}
				}
			}
		}
		if (g_slist_length (self->priv->candidates) > 1) {
			gboolean _tmp18_ = FALSE;
			if (has_nai) {
				_tmp18_ = nai_provided != NULL;
			} else {
				_tmp18_ = FALSE;
			}
			if (_tmp18_) {
				IdCard* _tmp19_;
				_data4_->identity = (_tmp19_ = _g_object_ref0 (nai_provided), _g_object_unref0 (_data4_->identity), _tmp19_);
				confirm = FALSE;
			} else {
				confirm = TRUE;
			}
		} else {
			IdCard* _tmp20_;
			_data4_->identity = (_tmp20_ = _g_object_ref0 ((IdCard*) g_slist_nth_data (self->priv->candidates, (guint) 0)), _g_object_unref0 (_data4_->identity), _tmp20_);
		}
		if (confirm) {
			gtk_tree_model_filter_refilter (self->priv->filter);
			main_window_redraw_id_card_widgets (self);
			gtk_widget_show ((GtkWidget*) self);
			_g_object_unref0 (nai_provided);
			block4_data_unref (_data4_);
			return;
		}
		_g_object_unref0 (nai_provided);
	}
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, __lambda3__gsource_func, block4_data_ref (_data4_), block4_data_unref);
	block4_data_unref (_data4_);
	return;
}


static gboolean main_window_match_service_pattern (MainWindow* self, const char* service, const char* pattern) {
	gboolean result = FALSE;
	GPatternSpec* pspec;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (service != NULL, FALSE);
	g_return_val_if_fail (pattern != NULL, FALSE);
	pspec = g_pattern_spec_new (pattern);
	result = g_pattern_match_string (pspec, service);
	_g_pattern_spec_free0 (pspec);
	return result;
}


void main_window_send_identity_cb (MainWindow* self, IdCard* identity) {
	IdentityRequest* request;
	gboolean reset_password;
	gboolean _tmp0_ = FALSE;
	GSList* _tmp12_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (identity != NULL);
	g_return_if_fail (self->request_queue->length > 0);
	request = (IdentityRequest*) g_queue_pop_head (self->request_queue);
	reset_password = FALSE;
	if (request->service != NULL) {
		_tmp0_ = _vala_strcmp0 (request->service, "") != 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint services_length1;
		gint _services_size_;
		char** _tmp2_;
		gint _tmp1_;
		char** services;
		gint _tmp7_;
		gint _tmp8_;
		char* _tmp9_;
		char** _tmp10_;
		services = (_tmp2_ = g_new0 (char*, (_tmp1_ + 1) + 1), services_length1 = _tmp1_ + 1, _services_size_ = services_length1, _tmp2_);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					gint _tmp4_;
					gint _tmp5_;
					char* _tmp6_;
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i < _tmp4_)) {
						break;
					}
					services[i] = (_tmp6_ = g_strdup (id_card_get_services (identity, &_tmp5_)[i]), _g_free0 (services[i]), _tmp6_);
				}
			}
		}
		services[_tmp7_] = (_tmp9_ = g_strdup (request->service), _g_free0 (services[_tmp7_]), _tmp9_);
		_tmp10_ = services;
		id_card_set_services (identity, _tmp10_, services_length1);
		identities_manager_store_id_cards (self->identities_manager);
		services = (_vala_array_free (services, services_length1, (GDestroyNotify) g_free), NULL);
	}
	if (id_card_get_password (identity) == NULL) {
		AddPasswordDialog* dialog;
		gint _result_;
		dialog = g_object_ref_sink (add_password_dialog_new ());
		_result_ = gtk_dialog_run ((GtkDialog*) dialog);
		switch (_result_) {
			case GTK_RESPONSE_OK:
			{
				id_card_set_password (identity, add_password_dialog_get_password (dialog));
				reset_password = !add_password_dialog_get_remember (dialog);
				break;
			}
			default:
			{
				identity = NULL;
				break;
			}
		}
		gtk_object_destroy ((GtkObject*) dialog);
		_g_object_unref0 (dialog);
	}
	if (g_queue_is_empty (self->request_queue)) {
		gtk_widget_hide ((GtkWidget*) self);
	}
	if (identity != NULL) {
		IdCard* _tmp11_;
		self->priv->default_id_card = (_tmp11_ = _g_object_ref0 (identity), _g_object_unref0 (self->priv->default_id_card), _tmp11_);
	}
	identity_request_return_identity (request, identity);
	if (reset_password) {
		id_card_set_password (identity, NULL);
	}
	self->priv->candidates = (_tmp12_ = NULL, __g_slist_free_g_object_unref0 (self->priv->candidates), _tmp12_);
	_g_object_unref0 (request);
}


static void main_window_label_make_bold (MainWindow* self, GtkLabel* label) {
	PangoFontDescription* font_desc;
	g_return_if_fail (self != NULL);
	g_return_if_fail (label != NULL);
	font_desc = pango_font_description_new ();
	pango_font_description_set_weight (font_desc, PANGO_WEIGHT_BOLD);
	gtk_widget_modify_font ((GtkWidget*) label, font_desc);
	_pango_font_description_free0 (font_desc);
}


static void _lambda1_ (GtkButton* remove_button, MainWindow* self) {
	GtkMessageDialog* dialog;
	gint ret;
	g_return_if_fail (remove_button != NULL);
	dialog = g_object_ref_sink ((GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) self, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO, _ ("Are you sure you want to stop '%s' ID Card to use %s?"), id_card_get_display_name (id_card_widget_get_id_card (custom_vbox_get_current_idcard (self->priv->custom_vbox)))));
	ret = gtk_dialog_run ((GtkDialog*) dialog);
	gtk_widget_hide ((GtkWidget*) dialog);
	if (ret == GTK_RESPONSE_YES) {
		IdCard* idcard;
		char* candidate;
		GSList* services;
		gint _tmp1_;
		char** _tmp2_;
		gint _tmp2__length1;
		char** _tmp3_;
		GList* children;
		idcard = _g_object_ref0 (id_card_widget_get_id_card (custom_vbox_get_current_idcard (self->priv->custom_vbox)));
		candidate = g_strdup ((const char*) g_hash_table_lookup (self->priv->service_button_map, remove_button));
		services = NULL;
		{
			gint _tmp0_;
			char** srv_collection;
			int srv_collection_length1;
			int srv_it;
			srv_collection = id_card_get_services (idcard, &_tmp0_);
			srv_collection_length1 = _tmp0_;
			for (srv_it = 0; srv_it < _tmp0_; srv_it = srv_it + 1) {
				char* srv;
				srv = g_strdup (srv_collection[srv_it]);
				{
					if (_vala_strcmp0 (srv, candidate) == 0) {
						_g_free0 (srv);
						continue;
					}
					services = g_slist_append (services, g_strdup (srv));
					_g_free0 (srv);
				}
			}
		}
		_tmp3_ = (_tmp2_ = g_new0 (char*, (_tmp1_ = g_slist_length (services)) + 1), _tmp2__length1 = _tmp1_, _tmp2_);
		id_card_set_services (idcard, _tmp3_, _tmp1_);
		_tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL);
		{
			gint j;
			j = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					gint _tmp5_;
					gint _tmp6_;
					gint _tmp7_;
					char* *_tmp8_;
					char* _tmp9_;
					if (!_tmp4_) {
						j++;
					}
					_tmp4_ = FALSE;
					if (!(j < _tmp5_)) {
						break;
					}
					_tmp8_ = &id_card_get_services (idcard, &_tmp7_)[j];
					(*_tmp8_) = (_tmp9_ = g_strdup ((const char*) g_slist_nth_data (services, (guint) j)), _g_free0 ((*_tmp8_)), _tmp9_);
				}
			}
		}
		children = gtk_container_get_children ((GtkContainer*) self->priv->services_internal_vbox);
		{
			GList* hbox_collection;
			GList* hbox_it;
			hbox_collection = children;
			for (hbox_it = hbox_collection; hbox_it != NULL; hbox_it = hbox_it->next) {
				GtkWidget* hbox;
				hbox = (GtkWidget*) hbox_it->data;
				{
					gtk_object_destroy ((GtkObject*) hbox);
				}
			}
		}
		main_window_fill_services_vbox (self, idcard);
		id_card_widget_update_id_card_label (custom_vbox_get_current_idcard (self->priv->custom_vbox));
		_g_list_free0 (children);
		__g_slist_free_g_free0 (services);
		_g_free0 (candidate);
		_g_object_unref0 (idcard);
	}
	_g_object_unref0 (dialog);
}


static void __lambda1__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	_lambda1_ (_sender, self);
}


static void main_window_fill_services_vbox (MainWindow* self, IdCard* id_card) {
	gint i;
	gint _tmp0_;
	gint n_columns;
	GtkTable* services_table;
	g_return_if_fail (self != NULL);
	g_return_if_fail (id_card != NULL);
	i = 0;
	n_columns = _tmp0_;
	services_table = g_object_ref_sink ((GtkTable*) gtk_table_new ((guint) n_columns, (guint) 2, FALSE));
	gtk_table_set_col_spacings (services_table, (guint) 10);
	gtk_table_set_row_spacings (services_table, (guint) 10);
	gtk_container_add ((GtkContainer*) self->priv->services_internal_vbox, (GtkWidget*) services_table);
	g_hash_table_remove_all (self->priv->service_button_map);
	{
		gint _tmp1_;
		char** service_collection;
		int service_collection_length1;
		int service_it;
		service_collection = id_card_get_services (id_card, &_tmp1_);
		service_collection_length1 = _tmp1_;
		for (service_it = 0; service_it < _tmp1_; service_it = service_it + 1) {
			char* service;
			service = g_strdup (service_collection[service_it]);
			{
				GtkLabel* label;
				GtkButton* remove_button;
				label = g_object_ref_sink ((GtkLabel*) gtk_label_new (service));
				gtk_misc_set_alignment ((GtkMisc*) label, (float) 0, (float) 0.5);
				remove_button = g_object_ref_sink ((GtkButton*) gtk_button_new_from_stock (GTK_STOCK_REMOVE));
				g_hash_table_insert (self->priv->service_button_map, _g_object_ref0 (remove_button), g_strdup (service));
				g_signal_connect_object (remove_button, "clicked", (GCallback) __lambda1__gtk_button_clicked, self, 0);
				gtk_table_attach_defaults (services_table, (GtkWidget*) label, (guint) 0, (guint) 1, (guint) i, (guint) (i + 1));
				gtk_table_attach_defaults (services_table, (GtkWidget*) remove_button, (guint) 1, (guint) 2, (guint) i, (guint) (i + 1));
				i++;
				_g_object_unref0 (remove_button);
				_g_object_unref0 (label);
				_g_free0 (service);
			}
		}
	}
	gtk_widget_show_all ((GtkWidget*) self->priv->services_internal_vbox);
	_g_object_unref0 (services_table);
}


static void main_window_on_about_action (MainWindow* self) {
	gint authors_length1;
	gint _authors_size_;
	char** _tmp1_;
	char** _tmp0_ = NULL;
	char** authors;
	char* copyright;
	char* license;
	g_return_if_fail (self != NULL);
	authors = (_tmp1_ = (_tmp0_ = g_new0 (char*, 4 + 1), _tmp0_[0] = g_strdup ("Javier Jardón <jjardon@codethink.co.uk>"), _tmp0_[1] = g_strdup ("Sam Thursfield <samthursfield@codethink.co.uk>"), _tmp0_[2] = g_strdup ("Alberto Ruiz <alberto.ruiz@codethink.co.uk>"), _tmp0_[3] = NULL, _tmp0_), authors_length1 = 4, _authors_size_ = authors_length1, _tmp1_);
	copyright = g_strdup ("Copyright 2011 JANET");
	license = g_strdup ("\n" \
"Copyright (c) 2011, JANET(UK)\n" \
"All rights reserved.\n" \
"\n" \
"Redistribution and use in source and binary forms, with or without\n" \
"modification, are permitted provided that the following conditions\n" \
"are met:\n" \
"\n" \
"1. Redistributions of source code must retain the above copyright\n" \
"   notice, this list of conditions and the following disclaimer.\n" \
"\n" \
"2. Redistributions in binary form must reproduce the above copyright\n" \
"   notice, this list of conditions and the following disclaimer in the" \
"\n" \
"   documentation and/or other materials provided with the distribution" \
".\n" \
"\n" \
"3. Neither the name of JANET(UK) nor the names of its contributors\n" \
"   may be used to endorse or promote products derived from this softwa" \
"re\n" \
"   without specific prior written permission.\n" \
"\n" \
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\" \
"\"AS IS\\\"\n" \
"AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, " \
"THE\n" \
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PUR" \
"POSE\n" \
"ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS" \
" BE LIABLE\n" \
"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUEN" \
"TIAL\n" \
"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOOD" \
"S\n" \
"OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n" \
"HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, ST" \
"RICT\n" \
"LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY " \
"WAY\n" \
"OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF" \
"\n" \
"SUCH DAMAGE.\n");
	gtk_show_about_dialog ((GtkWindow*) self, "comments", _ ("Moonshot project UI"), "copyright", copyright, "website", "http://www.project-moonshot.org/", "license", license, "website-label", _ ("Visit the Moonshot project web site"), "authors", authors, "translator-credits", _ ("translator-credits"), NULL, NULL);
	_g_free0 (license);
	_g_free0 (copyright);
	authors = (_vala_array_free (authors, authors_length1, (GDestroyNotify) g_free), NULL);
}


static void _vala_array_add1 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _main_window_add_identity_manual_cb_gtk_action_callback (GtkAction* action, gpointer self) {
	main_window_add_identity_manual_cb (self);
}


static void _vala_array_add2 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _gtk_main_quit_gtk_action_callback (GtkAction* action, gpointer self) {
	gtk_main_quit ();
}


static void _vala_array_add3 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _vala_array_add4 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static void _main_window_on_about_action_gtk_action_callback (GtkAction* action, gpointer self) {
	main_window_on_about_action (self);
}


static void _vala_array_add5 (GtkActionEntry** array, int* length, int* size, const GtkActionEntry* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkActionEntry, *array, *size);
	}
	(*array)[(*length)++] = *value;
}


static GtkActionEntry* main_window_create_actions (MainWindow* self, int* result_length1) {
	GtkActionEntry* result = NULL;
	gint actions_length1;
	gint _actions_size_;
	GtkActionEntry* _tmp0_;
	GtkActionEntry* actions;
	GtkActionEntry _tmp1_ = {0};
	GtkActionEntry filemenu;
	GtkActionEntry _tmp2_ = {0};
	GtkActionEntry add;
	GtkActionEntry _tmp3_ = {0};
	GtkActionEntry quit;
	GtkActionEntry _tmp4_ = {0};
	GtkActionEntry helpmenu;
	GtkActionEntry _tmp5_ = {0};
	GtkActionEntry about;
	GtkActionEntry* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	actions = (_tmp0_ = g_new0 (GtkActionEntry, 0), actions_length1 = 0, _actions_size_ = actions_length1, _tmp0_);
	filemenu = (_tmp1_.name = "FileMenuAction", _tmp1_.stock_id = NULL, _tmp1_.label = N_ ("_File"), _tmp1_.accelerator = NULL, _tmp1_.tooltip = NULL, _tmp1_.callback = (GCallback) NULL, _tmp1_);
	_vala_array_add1 (&actions, &actions_length1, &_actions_size_, &filemenu);
	add = (_tmp2_.name = "AddIdCardAction", _tmp2_.stock_id = GTK_STOCK_ADD, _tmp2_.label = N_ ("Add ID Card"), _tmp2_.accelerator = NULL, _tmp2_.tooltip = N_ ("Add a new ID Card"), _tmp2_.callback = (GCallback) _main_window_add_identity_manual_cb_gtk_action_callback, _tmp2_);
	_vala_array_add2 (&actions, &actions_length1, &_actions_size_, &add);
	quit = (_tmp3_.name = "QuitAction", _tmp3_.stock_id = GTK_STOCK_QUIT, _tmp3_.label = N_ ("Quit"), _tmp3_.accelerator = "<control>Q", _tmp3_.tooltip = N_ ("Quit the application"), _tmp3_.callback = (GCallback) _gtk_main_quit_gtk_action_callback, _tmp3_);
	_vala_array_add3 (&actions, &actions_length1, &_actions_size_, &quit);
	helpmenu = (_tmp4_.name = "HelpMenuAction", _tmp4_.stock_id = NULL, _tmp4_.label = N_ ("_Help"), _tmp4_.accelerator = NULL, _tmp4_.tooltip = NULL, _tmp4_.callback = (GCallback) NULL, _tmp4_);
	_vala_array_add4 (&actions, &actions_length1, &_actions_size_, &helpmenu);
	about = (_tmp5_.name = "AboutAction", _tmp5_.stock_id = GTK_STOCK_ABOUT, _tmp5_.label = N_ ("About"), _tmp5_.accelerator = NULL, _tmp5_.tooltip = N_ ("About this application"), _tmp5_.callback = (GCallback) _main_window_on_about_action_gtk_action_callback, _tmp5_);
	_vala_array_add5 (&actions, &actions_length1, &_actions_size_, &about);
	result = (_tmp6_ = actions, *result_length1 = actions_length1, _tmp6_);
	return result;
	actions = (g_free (actions), NULL);
}


static void main_window_create_ui_manager (MainWindow* self) {
	GtkActionGroup* action_group;
	gint _tmp0_;
	GtkActionEntry* _tmp1_;
	gint _tmp1__length1;
	GtkActionEntry* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	action_group = gtk_action_group_new ("GeneralActionGroup");
	_tmp2_ = (_tmp1_ = main_window_create_actions (self, &_tmp0_), _tmp1__length1 = _tmp0_, _tmp1_);
	gtk_action_group_add_actions (action_group, _tmp2_, _tmp0_, self);
	_tmp1_ = (g_free (_tmp1_), NULL);
	gtk_ui_manager_insert_action_group (self->priv->ui_manager, action_group, 0);
	{
		gtk_ui_manager_add_ui_from_string (self->priv->ui_manager, MAIN_WINDOW_layout, (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "%s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (action_group);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	gtk_ui_manager_ensure_update (self->priv->ui_manager);
	_g_object_unref0 (action_group);
}


static void _main_window_search_entry_icon_press_cb_gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self) {
	main_window_search_entry_icon_press_cb (self, p0, p1);
}


static void _main_window_search_entry_text_changed_cb_g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	main_window_search_entry_text_changed_cb (self);
}


static gboolean _main_window_search_entry_key_press_event_cb_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = main_window_search_entry_key_press_event_cb (self, event);
	return result;
}


static void main_window_build_ui (MainWindow* self) {
	GtkEntry* _tmp0_;
	GdkPixbuf* _tmp1_;
	GdkPixbuf* _tmp2_;
	CustomVBox* _tmp3_;
	GtkViewport* viewport;
	GtkScrolledWindow* scroll;
	GtkVBox* vbox_left;
	GtkLabel* login_vbox_title;
	GtkLabel* username_label;
	GtkEntry* _tmp4_;
	GtkLabel* password_label;
	GtkEntry* _tmp5_;
	GtkCheckButton* remember_checkbutton;
	GtkTable* login_table;
	GtkAlignment* login_vbox_alignment;
	GtkVBox* login_vbox;
	GtkLabel* services_vbox_title;
	GtkAlignment* services_vbox_alignment;
	GtkVBox* _tmp6_;
	GtkVBox* services_vbox;
	GtkVBox* _tmp7_;
	GtkHBox* hbox;
	GtkVBox* main_vbox;
	GtkWidget* menubar;
	g_return_if_fail (self != NULL);
	main_window_create_ui_manager (self);
	self->priv->search_entry = (_tmp0_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->search_entry), _tmp0_);
	main_window_set_atk_name_description (self, (GtkWidget*) self->priv->search_entry, _ ("Search entry"), _ ("Search for a specific ID Card"));
	gtk_entry_set_icon_from_pixbuf (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, _tmp1_ = find_icon_sized ("edit-find-symbolic", GTK_ICON_SIZE_MENU));
	_g_object_unref0 (_tmp1_);
	gtk_entry_set_icon_tooltip_text (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, _ ("Search identity or service"));
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_PRIMARY, FALSE);
	gtk_entry_set_icon_from_pixbuf (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, _tmp2_ = find_icon_sized ("edit-clear-symbolic", GTK_ICON_SIZE_MENU));
	_g_object_unref0 (_tmp2_);
	gtk_entry_set_icon_tooltip_text (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, _ ("Clear the current search"));
	gtk_entry_set_icon_sensitive (self->priv->search_entry, GTK_ENTRY_ICON_SECONDARY, FALSE);
	g_signal_connect_object (self->priv->search_entry, "icon-press", (GCallback) _main_window_search_entry_icon_press_cb_gtk_entry_icon_press, self, 0);
	g_signal_connect_object ((GObject*) self->priv->search_entry, "notify::text", (GCallback) _main_window_search_entry_text_changed_cb_g_object_notify, self, 0);
	g_signal_connect_object ((GtkWidget*) self->priv->search_entry, "key-press-event", (GCallback) _main_window_search_entry_key_press_event_cb_gtk_widget_key_press_event, self, 0);
	self->priv->custom_vbox = (_tmp3_ = g_object_ref_sink (custom_vbox_new (self, FALSE, 6)), _g_object_unref0 (self->priv->custom_vbox), _tmp3_);
	viewport = g_object_ref_sink ((GtkViewport*) gtk_viewport_new (NULL, NULL));
	gtk_container_set_border_width ((GtkContainer*) viewport, (guint) 6);
	gtk_viewport_set_shadow_type (viewport, GTK_SHADOW_NONE);
	gtk_container_add ((GtkContainer*) viewport, (GtkWidget*) self->priv->custom_vbox);
	scroll = g_object_ref_sink ((GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL));
	gtk_scrolled_window_set_policy (scroll, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	gtk_scrolled_window_set_shadow_type (scroll, GTK_SHADOW_IN);
	gtk_scrolled_window_add_with_viewport (scroll, (GtkWidget*) viewport);
	vbox_left = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	gtk_box_pack_start ((GtkBox*) vbox_left, (GtkWidget*) self->priv->search_entry, FALSE, FALSE, (guint) 6);
	gtk_box_pack_start ((GtkBox*) vbox_left, (GtkWidget*) scroll, TRUE, TRUE, (guint) 0);
	gtk_widget_set_size_request ((GtkWidget*) vbox_left, MAIN_WINDOW_WINDOW_WIDTH, 0);
	login_vbox_title = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Login: ")));
	main_window_label_make_bold (self, login_vbox_title);
	gtk_misc_set_alignment ((GtkMisc*) login_vbox_title, (float) 0, (float) 0.5);
	username_label = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Username:")));
	gtk_misc_set_alignment ((GtkMisc*) username_label, (float) 1, (float) 0.5);
	self->priv->username_entry = (_tmp4_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->username_entry), _tmp4_);
	password_label = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Password:")));
	gtk_misc_set_alignment ((GtkMisc*) password_label, (float) 1, (float) 0.5);
	self->priv->password_entry = (_tmp5_ = g_object_ref_sink ((GtkEntry*) gtk_entry_new ()), _g_object_unref0 (self->priv->password_entry), _tmp5_);
	gtk_entry_set_invisible_char (self->priv->password_entry, (gunichar) '*');
	gtk_entry_set_visibility (self->priv->password_entry, FALSE);
	remember_checkbutton = g_object_ref_sink ((GtkCheckButton*) gtk_check_button_new_with_label (_ ("Remember password")));
	login_table = g_object_ref_sink ((GtkTable*) gtk_table_new ((guint) 3, (guint) 3, FALSE));
	gtk_table_set_col_spacings (login_table, (guint) 10);
	gtk_table_set_row_spacings (login_table, (guint) 10);
	gtk_table_attach_defaults (login_table, (GtkWidget*) username_label, (guint) 0, (guint) 1, (guint) 0, (guint) 1);
	gtk_table_attach_defaults (login_table, (GtkWidget*) self->priv->username_entry, (guint) 1, (guint) 2, (guint) 0, (guint) 1);
	gtk_table_attach_defaults (login_table, (GtkWidget*) password_label, (guint) 0, (guint) 1, (guint) 1, (guint) 2);
	gtk_table_attach_defaults (login_table, (GtkWidget*) self->priv->password_entry, (guint) 1, (guint) 2, (guint) 1, (guint) 2);
	gtk_table_attach_defaults (login_table, (GtkWidget*) remember_checkbutton, (guint) 1, (guint) 2, (guint) 2, (guint) 3);
	login_vbox_alignment = g_object_ref_sink ((GtkAlignment*) gtk_alignment_new ((float) 0, (float) 0, (float) 0, (float) 0));
	gtk_alignment_set_padding (login_vbox_alignment, (guint) 0, (guint) 0, (guint) 12, (guint) 0);
	gtk_container_add ((GtkContainer*) login_vbox_alignment, (GtkWidget*) login_table);
	login_vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 6));
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) login_vbox_title, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) login_vbox, (GtkWidget*) login_vbox_alignment, FALSE, TRUE, (guint) 0);
	services_vbox_title = g_object_ref_sink ((GtkLabel*) gtk_label_new (_ ("Services:")));
	main_window_label_make_bold (self, services_vbox_title);
	gtk_misc_set_alignment ((GtkMisc*) services_vbox_title, (float) 0, (float) 0.5);
	services_vbox_alignment = g_object_ref_sink ((GtkAlignment*) gtk_alignment_new ((float) 0, (float) 0, (float) 0, (float) 0));
	gtk_alignment_set_padding (services_vbox_alignment, (guint) 0, (guint) 0, (guint) 12, (guint) 0);
	self->priv->services_internal_vbox = (_tmp6_ = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (TRUE, 6)), _g_object_unref0 (self->priv->services_internal_vbox), _tmp6_);
	gtk_container_add ((GtkContainer*) services_vbox_alignment, (GtkWidget*) self->priv->services_internal_vbox);
	services_vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 6));
	gtk_box_pack_start ((GtkBox*) services_vbox, (GtkWidget*) services_vbox_title, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) services_vbox, (GtkWidget*) services_vbox_alignment, FALSE, TRUE, (guint) 0);
	self->priv->vbox_right = (_tmp7_ = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 18)), _g_object_unref0 (self->priv->vbox_right), _tmp7_);
	gtk_box_pack_start ((GtkBox*) self->priv->vbox_right, (GtkWidget*) login_vbox, FALSE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) self->priv->vbox_right, (GtkWidget*) services_vbox, FALSE, TRUE, (guint) 0);
	hbox = g_object_ref_sink ((GtkHBox*) gtk_hbox_new (FALSE, 12));
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) vbox_left, TRUE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) self->priv->vbox_right, FALSE, FALSE, (guint) 0);
	main_vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	gtk_container_set_border_width ((GtkContainer*) main_vbox, (guint) 12);
	menubar = _g_object_ref0 (gtk_ui_manager_get_widget (self->priv->ui_manager, "/MenuBar"));
	gtk_box_pack_start ((GtkBox*) main_vbox, menubar, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) main_vbox, (GtkWidget*) hbox, TRUE, TRUE, (guint) 0);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) main_vbox);
	gtk_widget_show_all ((GtkWidget*) main_vbox);
	gtk_widget_hide ((GtkWidget*) self->priv->vbox_right);
	_g_object_unref0 (menubar);
	_g_object_unref0 (main_vbox);
	_g_object_unref0 (hbox);
	_g_object_unref0 (services_vbox);
	_g_object_unref0 (services_vbox_alignment);
	_g_object_unref0 (services_vbox_title);
	_g_object_unref0 (login_vbox);
	_g_object_unref0 (login_vbox_alignment);
	_g_object_unref0 (login_table);
	_g_object_unref0 (remember_checkbutton);
	_g_object_unref0 (password_label);
	_g_object_unref0 (username_label);
	_g_object_unref0 (login_vbox_title);
	_g_object_unref0 (vbox_left);
	_g_object_unref0 (scroll);
	_g_object_unref0 (viewport);
}


static void main_window_set_atk_name_description (MainWindow* self, GtkWidget* widget, const char* name, const char* description) {
	AtkObject* atk_widget;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (description != NULL);
	atk_widget = _g_object_ref0 (gtk_widget_get_accessible (widget));
	atk_object_set_name (atk_widget, name);
	atk_object_set_description (atk_widget, description);
	_g_object_unref0 (atk_widget);
}


static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self) {
	gtk_main_quit ();
}


static void main_window_connect_signals (MainWindow* self) {
	g_return_if_fail (self != NULL);
	g_signal_connect ((GtkObject*) self, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
}


static guint _dynamic_request_name0 (DBusGProxy* self, const char* param1, guint param2, GError** error) {
	guint result;
	dbus_g_proxy_call (self, "RequestName", error, G_TYPE_STRING, param1, G_TYPE_UINT, param2, G_TYPE_INVALID, G_TYPE_UINT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0U;
	}
	return result;
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}


static void main_window_init_ipc_server (MainWindow* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		DBusGConnection* conn;
		DBusGProxy* bus;
		guint reply;
		MoonshotServer* _tmp0_;
		conn = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == DBUS_GERROR) {
				goto __catch4_dbus_gerror;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		bus = dbus_g_proxy_new_for_name (conn, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus");
		reply = _dynamic_request_name0 (bus, "org.janet.Moonshot", (guint) 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (bus);
			_dbus_g_connection_unref0 (conn);
			if (_inner_error_->domain == DBUS_GERROR) {
				goto __catch4_dbus_gerror;
			}
			goto __finally4;
		}
		g_assert (reply == DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER);
		self->priv->ipc_server = (_tmp0_ = moonshot_server_new ((GtkWindow*) self), _g_object_unref0 (self->priv->ipc_server), _tmp0_);
		_vala_dbus_register_object (dbus_g_connection_get_connection (conn), "/org/janet/moonshot", (GObject*) self->priv->ipc_server);
		_g_object_unref0 (bus);
		_dbus_g_connection_unref0 (conn);
	}
	goto __finally4;
	__catch4_dbus_gerror:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "%s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally4:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


gint main_window_main (char** args, int args_length1) {
	gint result = 0;
	MainWindow* window;
	gtk_init (&args_length1, &args);
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	window = g_object_ref_sink (main_window_new ());
	gtk_widget_show ((GtkWidget*) window);
	gtk_main ();
	result = 0;
	_g_object_unref0 (window);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return main_window_main (argv, argc);
}


static void main_window_class_init (MainWindowClass * klass) {
	main_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MainWindowPrivate));
	G_OBJECT_CLASS (klass)->finalize = main_window_finalize;
}


static void main_window_instance_init (MainWindow * self) {
	self->priv = MAIN_WINDOW_GET_PRIVATE (self);
	self->priv->ui_manager = gtk_ui_manager_new ();
}


static void main_window_finalize (GObject* obj) {
	MainWindow * self;
	self = MAIN_WINDOW (obj);
	_g_object_unref0 (self->priv->ui_manager);
	_g_object_unref0 (self->priv->search_entry);
	_g_object_unref0 (self->priv->vbox_right);
	_g_object_unref0 (self->priv->custom_vbox);
	_g_object_unref0 (self->priv->services_internal_vbox);
	_g_object_unref0 (self->priv->username_entry);
	_g_object_unref0 (self->priv->password_entry);
	_g_object_unref0 (self->priv->listmodel);
	_g_object_unref0 (self->priv->filter);
	_g_object_unref0 (self->identities_manager);
	__g_slist_free_g_object_unref0 (self->priv->candidates);
	_g_object_unref0 (self->priv->ipc_server);
	_g_object_unref0 (self->priv->default_id_card);
	_g_queue_free0 (self->request_queue);
	_g_hash_table_unref0 (self->priv->service_button_map);
	G_OBJECT_CLASS (main_window_parent_class)->finalize (obj);
}


GType main_window_get_type (void) {
	static volatile gsize main_window_type_id__volatile = 0;
	if (g_once_init_enter (&main_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MainWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) main_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MainWindow), 0, (GInstanceInitFunc) main_window_instance_init, NULL };
		GType main_window_type_id;
		main_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "MainWindow", &g_define_type_info, 0);
		g_once_init_leave (&main_window_type_id__volatile, main_window_type_id);
	}
	return main_window_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




